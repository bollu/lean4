/-
Copyright (c) 2019 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura
-/
import Lean.Runtime
import Lean.Compiler.NameMangling
import Lean.Compiler.ExportAttr
import Lean.Compiler.InitAttr
import Lean.Compiler.IR.CompilerM
import Lean.Compiler.IR.EmitUtil
import Lean.Compiler.IR.NormIds
import Lean.Compiler.IR.SimpCase
import Lean.Compiler.IR.Boxing
import Lean.Data.KVMap
import Init.Data.List

open Std (HashMap)

namespace Lean.IR.EmitMLIR

open ExplicitBoxing (requiresBoxedVersion mkBoxedName isBoxedName)

-- | type of owner, is the parent a funcop or a caseop
inductive OwningBlockType where
  | funcop | caseop


inductive EmitIrrelevant where
  | yes | no


-- def mkModuleInitializationFunctionName (moduleName : Name) : String :=
def mkModuleInitializationFunctionNameHACK (moduleName : Name) : String :=
  "initialize_" ++  "main"



partial def lookupArgTy (tys: HashMap VarId IRType) (a: Arg) : IRType := 
  match a with 
  | Arg.var id => 
    match tys.find? id with
    | some ty => ty
    -- TODO: get stack trace? X(
    -- | Use IRType.union so we can see in the IR which value has missing types.
    -- | IRType.union is not generated by anything.
    | none => IRType.union "errorLookupArgTy".toName #[] --panic $ "unable to find type of arg"
  | Arg.irrelevant => IRType.irrelevant

def escape  {a : Type} [ToFormat a] : a -> Format
  | a => "\"" ++ format a ++ "\""



def leanMainFn := "main_lean_custom_entrypoint_hack"

structure Context where
  env        : Environment
  modName    : Name
  jpMap      : JPParamsMap := {}
  mainFn     : FunId := arbitrary
  mainParams : Array Param := #[]


structure State where
   out       : String := ""
   guid      : Nat := 0

   
-- need more state here to generate GUIDs
abbrev M := ReaderT Context (EStateM String State)

def assertM (s: String) (b: Bool) : M Unit := 
  if b
  then pure ()
  else do panic ("ASSERTION ERROR: " ++ s); pure ()


def panicM (s: String) : M Unit := do
  panic ("panic!: " ++ s); pure ()


def gensym (s: String) : M String := do
  -- let ix <- modifyGet (fun st => (ix, { st with guid := st.guid + 1}))
  let st <- get
  set ({ st with guid := st.guid + 1})
  pure ("G" ++ s ++ toString st.guid)
  

def getEnv : M Environment := Context.env <$> read
def getModName : M Name := Context.modName <$> read
def getDecl (n : Name) : M Decl := do
  let env ← getEnv
  match findEnvDecl env n with
  | some d => pure d
  | none   => throw s!"unknown declaration '{n}'"

@[inline] def emit {α : Type} [ToString α] (a : α) : M Unit :=
  modify fun st => { st with out := st.out ++ toString a }

@[inline] def emitLn {α : Type} [ToString α] (a : α) : M Unit := do
  emit a; emit "\n"

def emitLns {α : Type} [ToString α] (as : List α) : M Unit :=
  as.forM fun a => emitLn a

def argToCString (x : Arg) : String :=
  match x with
  | Arg.var x  => toString x
  | irrelevant => "irrelevant" -- "lean_box(0)"

def emitArg (x : Arg) : M Unit :=
  emit ("%" ++ (argToCString x))

def toCType : IRType → String
  | IRType.float      => "f64"
  | IRType.uint8      => "i8"
  | IRType.uint16     => "i16"
  | IRType.uint32     => "i32"
  | IRType.uint64     => "i64"
  | IRType.usize      => "i64" -- TODO: find some better way to encode size.
  | IRType.object     => "!lz.value" -- "lean_object*"
  | IRType.tobject    => "!lz.value" -- "lean_object*"
  | IRType.irrelevant => "!lz.value" -- "lean_object*"
  | IRType.struct _ _ => panic! "not implemented yet"
  | IRType.union _ _  => "!lz.value"  -- panic! "not implemented yet"

def throwInvalidExportName {α : Type} (n : Name) : M α :=
  throw s!"invalid export name '{n}'"

def toCName (n : Name) : M String := do
  let env ← getEnv;
  -- TODO: we should support simple export names only
  match getExportNameFor env n with
  | some (Name.str Name.anonymous s _) => pure s
  | some _                             => throwInvalidExportName n
  | none                               => if n == `main then pure leanMainFn else pure n.mangle

def emitCName (n : Name) : M Unit :=
  toCName n >>= emit


def toCInitName (n : Name) : M String := do
  let env ← getEnv;
  -- TODO: we should support simple export names only
  match getExportNameFor env n with
  | some (Name.str Name.anonymous s _) => pure $ "_init_" ++ s
  | some _                             => throwInvalidExportName n
  | none                               => pure ("_init_" ++ n.mangle)


def emitCInitName (n : Name) : M Unit :=
  toCInitName n >>= emit
 
-- called from emitFnFwdDecls -> emitFnFwdDecl
def emitFnFwdDeclAux (decl : Decl) (cppBaseName : String) (addExternForConsts : Bool) : M Unit := do
  emitLn $ "// ERR: emitFnFwdDeclAux (" ++ cppBaseName ++ ")"
  let ps := decl.params
  let env ← getEnv
  if ps.isEmpty
  then do
    emit (escape "ptr.global"); emit "()";
    emit $ "{value=@" ++ cppBaseName ++ ", type=" ++ (toCType decl.resultType) ++ "}";
    emitLn $ " : " ++  "() -> ()"; -- emit (toCType decl.resultType); emitLn "";
  else do
    emit ("func private @" ++ cppBaseName)
    emit "("
    -- We omit irrelevant parameters for extern constants
    let ps := if isExternC env decl.name then ps.filter (fun p => !p.ty.isIrrelevant) else ps
    if ps.size > closureMaxArgs && isBoxedName decl.name then
      emit "UNKNOWN_CASE_CLOSURE_MAX_ARGS"
      -- emit "lean_object**"
    else
      ps.size.forM fun i => do
        if i > 0 then emit ", "
        emit (toCType ps[i].ty)
    emit ")"
    emitLn (" -> " ++ (toCType decl.resultType))
 
-- called from emitFnDecls -> emitFnDecl
def emitFnFwdDecl (decl : Decl) (addExternForConsts : Bool) : M Unit := do
  emitLn "// ERR: emitFnFwdDecl"
  let cppBaseName ← toCName decl.name
  emitFnFwdDeclAux decl cppBaseName addExternForConsts

def emitExternFwdDeclAux (decl : Decl) (cNameStr : String) : M Unit := do
  let env ← getEnv
  let extC := isExternC env decl.name
  emitFnFwdDeclAux decl cNameStr (!extC)

def emitFnFwdDecls : M Unit := do
  let env ← getEnv
  let decls := getDecls env
  let modDecls  : NameSet := decls.foldl (fun s d => s.insert d.name) {}
  let usedDecls : NameSet := decls.foldl (fun s d => collectUsedDecls env d (s.insert d.name)) {}
  let usedDecls := usedDecls.toList
  usedDecls.forM fun n => do
    let decl ← getDecl n;
  --   if Decl.isExtern decl 
  --   then emitExternDeclAux decl cname
  --   else pure ()
    match getExternNameFor env `c decl.name with
    | some cName => do
            emitExternFwdDeclAux decl cName
   -- THIS IS DELICATE. We need forward declarations for GLOBALS, and not for
   -- FUNCTIONS. I can't forward declare functions because MLIR has stupid rules
   -- about redefining symbols (!). 
   -- So we check if it is a global. If it is, we spit out a forward
   -- declaration. If not, we do not.
    | none       => if decl.params.isEmpty -- is a global
                    then emitFnFwdDecl decl (!modDecls.contains n)
                    else if modDecls.contains n -- is a function declared in the module
                    then  pure ()
                    -- | is a function, NOT declared in the module
                    else emitFnFwdDecl decl (!modDecls.contains n)

-- def emitMainFn : M Unit := do
--   let d ← getDecl `main
--   match d with
--   | Decl.fdecl (f := f) (xs := xs) (type := t) (body := b) .. => do
--     unless xs.size == 2 || xs.size == 1 do throw "invalid main function, incorrect arity when generating code"
--     let env ← getEnv
--     let usesLeanAPI := usesModuleFrom env `Lean
--     if usesLeanAPI then
--        emitLn "void lean_initialize();"
--     else
--        emitLn "void lean_initialize_runtime_module();";
--     emitLn "
--   #if defined(WIN32) || defined(_WIN32)
--   #include <windows.h>
--   #endif
--  
--   int main(int argc, char ** argv) {
--   #if defined(WIN32) || defined(_WIN32)
--   SetErrorMode(SEM_FAILCRITICALERRORS);
--   #endif
--   lean_object* in; lean_object* res;";
--     if usesLeanAPI then
--       emitLn "lean_initialize();"
--     else
--       emitLn "lean_initialize_runtime_module();"
--     let modName ← getModName
--     emitLn ("res = " ++ mkModuleInitializationFunctionNameHACK modName ++ "(lean_io_mk_world());")
--     emitLns ["lean_io_mark_end_initialization();",
--              "if (lean_io_result_is_ok(res)) {",
--              "lean_dec_ref(res);",
--              "lean_init_task_manager();"];
--     if xs.size == 2 then
--       emitLns ["in = lean_box(0);",
--                "int i = argc;",
--                "while (i > 1) {",
--                " lean_object* n;",
--                " i--;",
--                " n = lean_alloc_ctor(1,2,0); lean_ctor_set(n, 0, lean_mk_string(argv[i])); lean_ctor_set(n, 1, in);",
--                " in = n;",
--               "}"]
--       emitLn ("res = " ++ leanMainFn ++ "(in, lean_io_mk_world());")
--     else
--       emitLn ("res = " ++ leanMainFn ++ "(lean_io_mk_world());")
--     emitLn "}"
--     emitLns ["if (lean_io_result_is_ok(res)) {",
--              "  int ret = lean_unbox(lean_io_result_get_value(res));",
--              "  lean_dec_ref(res);",
--              "  return ret;",
--              "} else {",
--              "  lean_io_result_show_error(res);",
--              "  lean_dec_ref(res);",
--              "  return 1;",
--              "}"]
--     emitLn "}"
--   | other => throw "function declaration expected"
--  
-- def hasMainFn : M Bool := do
--   let env ← getEnv
--   let decls := getDecls env
--   pure $ decls.any (fun d => d.name == `main)
--  
-- def emitMainFnIfNeeded : M Unit := do
--   if (← hasMainFn) then emitMainFn

-- Prelude
def emitPreamble : M Unit := do
  let env ← getEnv
  let modName ← getModName
  emitLn "// Lean compiler output"
  emitLn ("// Module: " ++ toString modName)
  emit "// Imports:"
  env.imports.forM fun m => emit (" " ++ toString m); emitLn ""
  emitLn "func private @lean_unbox_float(!lz.value) -> f64"
  emitLn "func private @lean_io_mk_world() -> (!lz.value)"
  emitLn "func private @lean_dec_ref(!lz.value) -> ()"
  emitLn "func private @lean_box(i64) -> !lz.value"
  emitLn "func private @lean_io_result_mk_ok(!lz.value) -> !lz.value"
  emitLn "func private @lean_mark_persistent(!lz.value) -> ()"
  emitLn "func private @lean_box_uint32(i32) -> (!lz.value)"


def emitFileHeader : M Unit := do
  let env ← getEnv
  let modName ← getModName
  emitLn "// Lean compiler output"
  emitLn ("// Module: " ++ toString modName)
  emit "// Imports:"
  env.imports.forM fun m => emit (" " ++ toString m)
  emitLn ""
  emitLn "#include <lean/lean.h>"
  emitLns [
    "#if defined(__clang__)",
    "#pragma clang diagnostic ignored \"-Wunused-parameter\"",
    "#pragma clang diagnostic ignored \"-Wunused-label\"",
    "#elif defined(__GNUC__) && !defined(__CLANG__)",
    "#pragma GCC diagnostic ignored \"-Wunused-parameter\"",
    "#pragma GCC diagnostic ignored \"-Wunused-label\"",
    "#pragma GCC diagnostic ignored \"-Wunused-but-set-variable\"",
    "#endif",
    "#ifdef __cplusplus",
    "extern \"C\" {",
    "#endif"
  ]

def emitFileFooter : M Unit :=
  emitLns [
   "#ifdef __cplusplus",
   "}",
   "#endif"
  ]

def throwUnknownVar {α : Type} (x : VarId) : M α :=
  throw s!"unknown variable '{x}'"

def getJPParams (j : JoinPointId) : M (Array Param) := do
  let ctx ← read;
  match ctx.jpMap.find? j with
  | some ps => pure ps
  | none    => throw "unknown join point"

def declareVar (x : VarId) (t : IRType) : M Unit := do
  emit (toCType t); emit " "; emit x; emit "; "

def declareParams (ps : Array Param) : M Unit :=
  ps.forM fun p => declareVar p.x p.ty



partial def declareVars : FnBody → Bool → M Bool
  | e@(FnBody.vdecl x t _ b), d => do
    let ctx ← read
    if isTailCallTo ctx.mainFn e then
      pure d
    else
      declareVar x t; declareVars b true
  | FnBody.jdecl j xs _ b,    d => do declareParams xs; declareVars b (d || xs.size > 0)
  | e,                        d => if e.isTerminal then pure d else declareVars e.body d

def emitTag (x : VarId) (xType : IRType) : M Unit := do
  if xType.isObj then do -- TODO: steal for case v/s caseInt
    emit "lean_obj_tag("; emit x; emit ")"
  else
    emit x

def isIf (alts : Array Alt) : Option (Nat × FnBody × FnBody) :=
  if alts.size != 2 then none
  else match alts[0] with
    | Alt.ctor c b => some (c.cidx, b, alts[1].body)
    | _            => none

def emitInc (x : VarId) (n : Nat) (checkRef : Bool) : M Unit := do
  emit "call ";
  emit $
    if checkRef then (if n == 1 then "lean_inc" else "lean_inc_n")
    else (if n == 1 then "lean_inc_ref" else "lean_inc_ref_n")
  emit "("; emit "%"; emit x
  if n != 1 then emit ", "; emit n
  emitLn ")"
  emitLn " : !lz.value -> ()"

def emitDec (x : VarId) (n : Nat) (checkRef : Bool) : M Unit := do
  emit "call "; emit "@";
  emit (if checkRef then "lean_dec" else "lean_dec_ref");
  emit "("; emit x;
  if n != 1 then emit ", "; emit n
  emitLn ");"

def emitDel (x : VarId) : M Unit := do
  emit "lean_free_object("; emit x; emitLn ");"

def emitSetTag (x : VarId) (i : Nat) : M Unit := do
  emit "lean_ctor_set_tag("; emit x; emit ", "; emit i; emitLn ");"

def emitSet (x : VarId) (i : Nat) (y : Arg) : M Unit := do
  emit "lean_ctor_set("; emit x; emit ", "; emit i; emit ", "; emitArg y; emitLn ");"

def emitOffset (n : Nat) (offset : Nat) : M Unit := do
  if n > 0 then
    emit "sizeof(void*)*"; emit n;
    if offset > 0 then emit " + "; emit offset
  else
    emit offset

def emitUSet (x : VarId) (n : Nat) (y : VarId) : M Unit := do
  emit "lean_ctor_set_usize("; emit x; emit ", "; emit n; emit ", "; emit y; emitLn ");"

def emitSSet (x : VarId) (n : Nat) (offset : Nat) (y : VarId) (t : IRType) : M Unit := do
  match t with
  | IRType.float  => emit "lean_ctor_set_float"
  | IRType.uint8  => emit "lean_ctor_set_uint8"
  | IRType.uint16 => emit "lean_ctor_set_uint16"
  | IRType.uint32 => emit "lean_ctor_set_uint32"
  | IRType.uint64 => emit "lean_ctor_set_uint64"
  | _             => throw "invalid instruction";
  emit "("; emit x; emit ", "; emitOffset n offset; emit ", "; emit y; emitLn ");"

def emitLhs (z : VarId) : M Unit := do
  emit "%"; emit z; emit " = "

-- | emit the type of the argument
def emitArgTy (a: Arg) (tys: HashMap VarId IRType) : M Unit :=  do
    emit (toCType (lookupArgTy tys a));

-- | emit the tpe of a variable
def emitVarTy (v: VarId) (tys: HashMap VarId IRType) : M Unit :=  do
    emit (toCType (lookupArgTy tys (mkVarArg v)));


-- | emit args with types interleaved
def emitArgsInterleavedTys (ys: Array Arg) (tys: HashMap VarId IRType) : M Unit :=
  ys.size.forM fun i => do
    if i > 0 then emit ", "
    emitArg ys[i];
    emit " : ";
    emitArgTy ys[i] tys

-- | emit only the types of the arguments
def emitArgsOnlyTys (ys: Array Arg) (tys: HashMap VarId IRType) : M Unit :=
  ys.size.forM fun i => do
    if i > 0 then emit ", "
    emit (toCType (lookupArgTy tys ys[i]));


def emitArgs (ys : Array Arg) : M Unit :=
  ys.size.forM fun i => do
    if i > 0 then emit ", "
    emitArg ys[i]


-- | this emits a jmp as a lz instruction
def emitJmp (j : JoinPointId) (xs : Array Arg)
  (tys: HashMap VarId IRType) : M Unit := do
  -- let ps ← getJPParams j
  -- unless xs.size == ps.size do throw "invalid goto"
  emit (escape "lz.jump"); emit "(";
  xs.size.forM fun i => do
    -- let p := ps[i]
    let x := xs[i]
    if i > 0 then emit ", ";
    emitArg xs[i];
  emit $ "){value=" ++ (toString j.idx) ++  "}";
  emit ": ("; emitArgsOnlyTys  xs tys; emit ")"; emitLn " -> ()";

-- | this emits a jmp as a LLVM branch 
-- def emitJmp (j : JoinPointId) (xs : Array Arg)
--   (tys: HashMap VarId IRType) : M Unit := do
--   -- let ps ← getJPParams j
--   -- unless xs.size == ps.size do throw "invalid goto"
--   emit "br "; emit ("^jp" ++ (toString j.idx)); emit "(";
--   xs.size.forM fun i => do
--     -- let p := ps[i]
--     let x := xs[i]
--     if i > 0 then emit ", ";
--     emitArg xs[i]; emit " : "; emit (toCType (lookupArgTy tys x));
--   emitLn ")";


def emitCtorScalarSize (usize : Nat) (ssize : Nat) : M Unit := do
  if usize == 0 then emit ssize
  else if ssize == 0 then emit "sizeof(size_t)*"; emit usize
  else emit "sizeof(size_t)*"; emit usize; emit " + "; emit ssize

def emitAllocCtor (c : CtorInfo) : M Unit := do
  -- let idxName := gensym "idx";
  -- emit $ "%" ++ idxName ++ " = " ++ "constant " ++ c.idx ++ " : i64";
  emit "lean_alloc_ctor("; emit c.cidx; emit ", "; emit c.size; emit ", "
  emitCtorScalarSize c.usize c.ssize; emitLn ");"

def emitCtorSetArgs (z : VarId) (ys : Array Arg) : M Unit := 
  ys.size.forM fun i => do
    emit "lean_ctor_set("; emit z; emit ", "; emit i; emit ", "; emitArg ys[i]; emitLn ");"

-- | TODO: raise to a higher abstraction level. Generate !lz.construct()
-- instead of the raw calls. 
-- For now, generate the raw calls to check that can lower correctly?
def emitExprCtor (z : VarId) (c : CtorInfo) (ys : Array Arg)
  (tys: HashMap VarId IRType): M Unit := do
  emitLhs z;
  emit (escape "lz.construct"); 
  emit "("; emitArgs ys;  emit ")";
  emit "{dataconstructor = @"; emit (escape c.cidx); emit  (", size=" ++ (toString c.size) ++ "}");
  emit " : ";
  emit "("; emitArgsOnlyTys ys tys; emitLn ") -> (!lz.value)";
  -- if c.size == 0 && c.usize == 0 && c.ssize == 0 then do
  --   let idxName <- gensym "idx";
  --   emit $ "%" ++ idxName ++ " = " ++ "constant " ++ (format c.cidx) ++ " : i64";
  --   emit "call @lean_box("; emit ("%" ++ idxName); emit ");"
  --   emit " : (i64) -> !lz.value"; emitLn "";
  -- else do
  --   emitAllocCtor c; emitCtorSetArgs z ys

def emitReset (z : VarId) (n : Nat) (x : VarId) : M Unit := do
  emit "if (lean_is_exclusive("; emit x; emitLn ")) {";
  n.forM fun i => do
    emit " lean_ctor_release("; emit x; emit ", "; emit i; emitLn ");"
  emit " "; emitLhs z; emit x; emitLn ";";
  emitLn "} else {";
  emit " lean_dec_ref("; emit x; emitLn ");";
  emit " "; emitLhs z; emitLn "lean_box(0);";
  emitLn "}"

def emitReuse (z : VarId) (x : VarId) (c : CtorInfo) (updtHeader : Bool) (ys : Array Arg) : M Unit := do
  emit "if (lean_is_scalar("; emit x; emitLn ")) {";
  emit " "; emitLhs z; emitAllocCtor c;
  emitLn "} else {";
  emit " "; emitLhs z; emit x; emitLn ";";
  if updtHeader then emit " lean_ctor_set_tag("; emit z; emit ", "; emit c.cidx; emitLn ");"
  emitLn "}";
  emitCtorSetArgs z ys

def emitProj (z : VarId) (i : Nat) (x : VarId) (tys: HashMap VarId IRType): M Unit := do
  emitLhs z; emit (escape "lz.project");
  emit "("; emit "%"; emit x; emit ")"; 
  emit "{value="; emit i; emit "}";
  emit ":"; emit "("; emitVarTy x tys; emit ")"; emit "  -> ";
  emit "("; emitVarTy z tys; emit ")"; emitLn "";

def emitUProj (z : VarId) (i : Nat) (x : VarId) : M Unit := do
  emitLhs z; emit "lean_ctor_get_usize("; emit x; emit ", "; emit i; emitLn ");"

def emitSProj (z : VarId) (t : IRType) (n offset : Nat) (x : VarId) : M Unit := do
  emitLhs z;
  match t with
  | IRType.float  => emit "lean_ctor_get_float"
  | IRType.uint8  => emit "lean_ctor_get_uint8"
  | IRType.uint16 => emit "lean_ctor_get_uint16"
  | IRType.uint32 => emit "lean_ctor_get_uint32"
  | IRType.uint64 => emit "lean_ctor_get_uint64"
  | _             => throw "invalid instruction"
  emit "("; emit x; emit ", "; emitOffset n offset; emitLn ");"

def toStringArgs (ys : Array Arg) : List String :=
  ys.toList.map argToCString


-- | ps: description of formal parameters to the function f.
def emitSimpleExternalCall (f : String) (ps : Array Param) (ys : Array Arg)
  (tys: HashMap VarId IRType) (retty: IRType) : M Unit := do
  -- let fname <- toCName f; -- added by bollu
  let fname := f;
  emit "call "; emit "@"; emit (escape fname)
  -- We must remove irrelevant arguments to extern calls
  let pys := (ps.zip ys).filter (fun py => not (py.fst.ty.isIrrelevant))
  let ys := Array.map Prod.snd pys

  emit "("
  -- We must remove irrelevant arguments to extern calls.
  pys.size.forM (fun i => do
         if i > 0 then emit ", ";
         emitArg ys[i])
  emit ")"
  emit " : ("; emitArgsOnlyTys ys tys; emit ")";
  emit " -> "; emit "(";  emit (toCType retty);  emit ")";
  emit " // <== ERR: emitSimpleExternalCall";
  emit "\n"
  pure ()


def emitExternCall (f : FunId)
                   (ps : Array Param)
                   (extData : ExternAttrData)
                   (ys : Array Arg)      
                   (tys: HashMap VarId IRType)
                   (retty: IRType) : M Unit := do
   match getExternEntryFor extData `c with
  | some (ExternEntry.standard _ extFn) => do
         emitSimpleExternalCall extFn ps ys tys retty
         emitLn "// ^^ ERR: ExternEntry.standard"; 
  | some (ExternEntry.inline _ pat)     => do 
         emit (expandExternPattern pat (toStringArgs ys)); emitLn ";"
         emitLn $ "//^^ ERR: ExternEntry.inline [pat: " ++ pat ++ "]"; 

  | some (ExternEntry.foreign _ extFn)  => do
         emitSimpleExternalCall extFn ps ys tys retty
         emitLn "// ^^ ERR: ExternEntry.foreign"; 
  | _ => throw s!"failed to emit extern application '{f}'"


def emitFullApp  (f : FunId) (ys : Array Arg) (tys: HashMap VarId IRType) : M Unit := do
  let decl ← getDecl f
  match decl with
  | Decl.extern _ ps _ extData => do        
         emitExternCall f ps extData ys tys (Decl.resultType decl)
         emitLn "// ^^^ ERR: emitFullApp (Decl.extern)"
  | _ => do
    if ys.size == 0
    then
      -- let declAddr <- gensym "declAddr";
      -- -- %0 = llvm.mlir.addressof @const : !llvm.ptr<i32>
      -- emit ("%" ++ declAddr); emit " = "; emit "llvm.mlir.addressof";
      -- emit "@";
      -- let cname <-  toCName f
      -- emit (escape cname);
      -- emit " : "; emit "!llvm.ptr<"; emit (toCType (Decl.resultType decl));  emitLn ">"; 
      -- --   %1 = llvm.load %0 : !llvm.ptr<i32>
      -- emitLhs z; emit "llvm.load "; emit ("%" ++ declAddr);
      -- emit " : "; emit "!llvm.ptr<"; emit (toCType (Decl.resultType decl));  emitLn ">"

      emit (escape "ptr.loadglobal"); emit "()";
      let cname <- toCName f; 
      emit "{value=@"; emit (escape cname); emit "}";
      emit " : () -> ";emit (toCType (Decl.resultType decl));
      emitLn "// <== ERR: emitFullApp (pointer)"
      emitLn "";
    else 
      emit "call "
      emit "@";
      let cname <-  toCName f
      emit (escape cname)
      emit "("; emitArgs ys; emit ")" 
      emit ":"; emit "("; emitArgsOnlyTys ys tys; emit ")"
      emit "->"
      emit "(";  emit (toCType (Decl.resultType decl)); emit ")"
      emitLn "// <== ERR: emitFullApp (fncall)"
      emit "\n"



--  create a new pap
def emitPartialApp (z : VarId) (f : FunId)
  (ys : Array Arg) (tys: HashMap VarId IRType): M Unit := do
  let decl ← getDecl f
  let arity := decl.params.size;
  emitLhs z; 
  emit (escape "lz.pap"); emit "("; emitArgs ys; emit ") ";
  emit "{value=@"; emitCName f; emit "} ";
  emit " : "; emit "("; emitArgsOnlyTys ys tys; emit ")"; emitLn " -> (!lz.value)";
  -- emit "lean_alloc_closure((void*)("; emitCName f; emit "), ";
  -- emit arity; emit ", "; emit ys.size; emitLn ");";
  -- ys.size.forM fun i => do
  --   let y := ys[i]
  --   emit "lean_closure_set("; emit z; emit ", "; emit i; emit ", "; emitArg y; emitLn ");"

-- | this is the thing that extends an application
def emitApp (z : VarId) (f : VarId) (ys : Array Arg) (tys: HashMap VarId IRType): M Unit :=
  if ys.size > closureMaxArgs then do
    -- emit "{ lean_object* _aargs[] = {"; emitArgs ys; emitLn "};";
    -- emitLhs z; emit "lean_apply_m("; emit f; emit ", "; emit ys.size; emitLn ", _aargs); }"
    -- TODO: what is the difference between pap and papm? In particular,
    -- what are these CLOSURE_MAX_ARGS thing?
    panicM "// ERR: emitApp : ys.size > closureMaxArgs"
    emitLhs z; emit (escape "lz.papExtendM");
    emit "("; emitArgs ys; emit ")";
    emit ": (";  emitArgsOnlyTys ys tys; emit ") -> !lz.value"
    emitLn "\n";
  else do
    emitLhs z; emit (escape ("lz.papExtend")); 
    emit "("; emit "%"; emit f; emit ", "; emitArgs ys; emit ")";
    emit " : ("; emit "!lz.value ,"; emitArgsOnlyTys ys tys; emit ")";
    emit " -> ";
    emit "("; emitVarTy z tys; emit ")"; 
    emitLn "";

def emitBoxFn (xType : IRType) : M Unit :=
  match xType with
  | IRType.usize  => emit "call @lean_box_usize"
  | IRType.uint32 => emit "call @lean_box_uint32"
  | IRType.uint64 => emit "call @lean_box_uint64"
  | IRType.float  => emit "call @lean_box_float"
  | other         => emit "call @lean_box"

def emitBox (z : VarId) (x : VarId) (xType : IRType) : M Unit := do
  emitLhs z; emitBoxFn xType; emit "(%"; emit x; emitLn ") : ";
  emit "("; emit "i32"; emit ") -> (!lz.value)"; emit "\n"

def emitUnbox (z : VarId) (t : IRType) (x : VarId) : M Unit := do
  emitLhs z;
  match t with
  | IRType.usize  => emit "call @lean_unbox_usize"
  | IRType.uint32 => emit "call @lean_unbox_uint32"
  | IRType.uint64 => emit "call @lean_unbox_uint64"
  | IRType.float  => emit "call @lean_unbox_float"
  | other         => emit "call @lean_unbox";
  emit "(%"; emit x; emit ") : ";
  emit "(!lz.value)"; emit " -> ("; emit (toCType t); emit ")";
  emit "\n"
  

def emitIsShared (z : VarId) (x : VarId) : M Unit := do
  emitLhs z; emit "!lean_is_exclusive("; emit x; emitLn ");"

def emitIsTaggedPtr (z : VarId) (x : VarId) : M Unit := do
  emitLhs z; emit "!lean_is_scalar("; emit x; emitLn ");"

def toHexDigit (c : Nat) : String :=
  String.singleton c.digitChar

def quoteString (s : String) : String :=
  let q := "\"";
  let q := s.foldl
    (fun q c => q ++
      if c == '\n' then "\\n"
      else if c == '\n' then "\\t"
      else if c == '\\' then "\\\\"
      else if c == '\"' then "\\\""
      else if c.toNat <= 31 then
        "\\x" ++ toHexDigit (c.toNat / 16) ++ toHexDigit (c.toNat % 16)
      -- TODO(Leo): we should use `\unnnn` for escaping unicode characters.
      else String.singleton c)
    q;
  q ++ "\""

def emitNumLit (t : IRType) (v : Nat) : M Unit := do
  if t.isObj then
    if v < UInt32.size then do
      emit (escape "lz.int");
      emit "(){value="; emit v; emit "}"; 
      emit ": () ->"; emit "(";  emit (toCType t); emit ")"; emit "\n";
      -- emit "lean_unsigned_to_nat("; emit v; emit "u)"
    else
     panicM "// ERR: lean_cstr_to_nat"
      -- emit "call @lean_cstr_to_nat(\""; emit v; emit "\")"
  else
    emit "std.constant "; emit v; emit " : "; emitLn (toCType t);


def emitLit (z : VarId) (t : IRType) (v : LitVal) : M Unit := do
  emitLhs z;
  match v with
  | LitVal.num v => emitNumLit t v
  | LitVal.str v => 
     emit (escape "lz.string"); emit "()"; emit "{value="; emit (quoteString v); emit "}";
     emit ": () -> "; emit "("; emit (toCType t); emit ")";
     emitLn "";

-- | emit expression / Expr
def emitVDecl (z : VarId) (t : IRType) (v : Expr)  (tys: HashMap VarId IRType) : M Unit :=
  match v with
  | Expr.ctor c ys      => emitExprCtor z c ys tys
  | Expr.reset n x      => panicM "// ERR: Expr.reset" -- emitReset z n x
  | Expr.reuse x c u ys => panicM "// ERR: Expr.reuse" -- emitReuse z x c u ys
  | Expr.proj i x       => do
      emitLn "// ERR: Expr.proj"
      emitProj z i x tys
  | Expr.uproj i x      => panicM "// ERR: Expr.uproj" -- emitUProj z i x
  | Expr.sproj n o x    => panicM "// ERR: Expr.sproj" -- emitSProj z t n o x
  | Expr.fap c ys       => do
    emitLn "// ERR: Expr.fap";
    emitLhs z; 
    emitFullApp c ys tys
  | Expr.pap c ys       =>  do
      emitLn "// ERR: Expr.pap"
      emitPartialApp z c ys tys
  | Expr.ap x ys        =>  do
     emitLn "// Err: Expr.ap"; 
     emitApp z x ys tys
  | Expr.box t x        => do
    emitLn "// ERR: Expr.box"
    emitBox z x t
  |
   Expr.unbox x        => do
    emitLn "// ERR: Expr.unbox"
    emitUnbox z t x
  | Expr.isShared x     => panicM  "// ERR: Expr.isShared" -- emitIsShared z x
  | Expr.isTaggedPtr x  => panicM "// ERR: Expr.isTaggedPtr: " -- emitIsTaggedPtr z x
  | Expr.lit v          => do emitLn "//ERR: Expr.lit"; emitLit z t v

def isTailCall (x : VarId) (v : Expr) (b : FnBody) : M Bool := do
  let ctx ← read;
  match v, b with
  | Expr.fap f _, FnBody.ret (Arg.var y) => pure $ f == ctx.mainFn && x == y
  | _, _ => pure false

def paramEqArg (p : Param) (x : Arg) : Bool :=
  match x with
  | Arg.var x => p.x == x
  | _ => false

/-
Given `[p_0, ..., p_{n-1}]`, `[y_0, ..., y_{n-1}]`, representing the assignments
```
p_0 := y_0,
...
p_{n-1} := y_{n-1}
```
Return true iff we have `(i, j)` where `j > i`, and `y_j == p_i`.
That is, we have
```
      p_i := y_i,
      ...
      p_j := p_i, -- p_i was overwritten above
```
-/
def overwriteParam (ps : Array Param) (ys : Array Arg) : Bool :=
  let n := ps.size;
  n.any $ fun i =>
    let p := ps[i]
    (i+1, n).anyI fun j => paramEqArg p ys[j]

-- | Heavily modified. Just does a regular call.
-- | TODO: add an attribute to my call instruction that tracks that 
-- this must translate into a @llvm.musttail. This ensure that
-- tail call semantics are preserved, while possibly allowing for better
-- codegen/LLVM shenanigans.
def emitTailCall (v : Expr) (tys: HashMap VarId IRType): M Unit :=
  match v with
  | Expr.fap f ys => do
     let decl ← getDecl f
     -- | good old war3 JASS memories...
     let ret <- gensym "retTailCall"
     emit ("%" ++ ret ++ " = "); emitFullApp f ys tys
     emit $ (escape "lz.return")  ++ "(%" ++ ret ++  ")";
     emit " : ("; emit (toCType decl.resultType); emit ") -> ()"
     emitLn ""
  | _ => throw "bug at emitTailCall"

mutual

-- partial def emitIf (x : VarId) (xType : IRType) (tag : Nat) (t : FnBody) (e : FnBody) : M Unit := do
--   emit "eif ("; emitTag x xType; emit " == "; emit tag; emitLn ")";
--   emitFnBody t {} EmitIrrelevant.no;
--   emitLn "else";
--   emitFnBody e {} EmitIrrelevant.no;


-- I have no idea why writing `do` notation gives me weird
-- universe errors. I believe that in LEAN, it is illegal to leave a
-- monadic value "unconsumed". So if `f, g :: m a`:
-- it is illegal to write [do f; g]
-- One MUST write [do let _ <- f; let _ <- g]
-- TODO: upstream this.
partial def forMIx_ [Monad m] 
  (f : Nat → α → m Unit) (as : Array α)  (start := 0) (stop := as.size): m Unit := do
  as.foldlM (init := 0) (start := start) (stop := stop) 
    (fun i v => do let _ <- (f i v); pure (i+1)) *> pure ()



partial def emitCaseObj (x : VarId) (xType : IRType) (alts : Array Alt) 
        (tys: HashMap VarId IRType): M Unit := do
 emit (escape ("lz.caseRet")); emit "("; emit "%"; emit x; emit ")";
 emit "("; 
 forMIx_ (as:= alts) (fun ix alt => do
    emit (if ix > 0 then ", " else "");
    match alt with 
     |  Alt.ctor info b => emitFnBody b tys EmitIrrelevant.no
     |  Alt.default b => emitFnBody b tys EmitIrrelevant.no) 
 emit ")";
 emitLn "";
 -- TODO: emit case LHSs
 -- TODO: emit return type of case. How?
 emit " : ";
 emit "("; emit (toCType xType); emit ")"; emit " -> "; emit "()";
 emitLn "";

-- | when does this EVER emit a default? As far as I can tell, integer pattern matches
-- are emitted as 
--   caseInt lean_dec_eq(x, LHS) { 0 -> ...; 1 -> ... }
-- so there is no way to even GET a @default.
partial def emitCaseInt (x : VarId) (xType : IRType) (alts : Array Alt) 
        (tys: HashMap VarId IRType): M Unit := do
 emit (escape ("lz.caseIntRet")); emit "("; emit "%"; emit x; emit ")";
 emit "("; 
 forMIx_ (as:= alts) (fun ix alt => do
    emit (if ix > 0 then ", " else "");
    match alt with 
     |  Alt.ctor info b => emitFnBody b tys EmitIrrelevant.no
     |  Alt.default b => emitFnBody b tys EmitIrrelevant.no)
 emit ")";
 emitLn "";
 emit "{";
 forMIx_ (as:= alts) (fun ix alt => do
     emit (if ix > 0 then ", " else "");
     emit $ "alt" ++ (toString ix) ++ "=";
     match alt with
      | Alt.ctor info b => emit info.cidx
      | Alt.default b => emit "@default"; 
 )
 emit "}";
 -- TODO: emit case LHSs
 -- TODO: emit return type of case. How  ?
 emit " : ";
 emit "("; emit (toCType xType); emit ")"; emit " -> "; emit "()";
 emitLn "";
 
 

partial def emitCase (x : VarId) (xType : IRType) (alts : Array Alt) 
        (tys: HashMap VarId IRType): M Unit :=
  if xType.isObj
  then emitCaseObj x xType alts tys
  else emitCaseInt x xType alts tys -- this is encoded as an if-then-else.

 
                      
 -- emitLn $ (escape "lz.caseRet") ++ "(%" ++ format x ++ ")" ++
 -- "("  ++ formatArray (Array.map (formatAltRHS loop indent) cs) ++ ")" 
 -- ++ "{" ++ formatArray (Array.map (formatAltLHS (cs.size) indent) cs)  ++ "}" 
 -- ++ ":" ++ formatMLIRType 1 0
                                   

  -- match isIf alts with
  -- | some (tag, t, e) => emitIf x xType tag t e
  -- | _ => do
  --   emit "switch ("; emitTag x xType; emitLn ") {";
  --   let alts := ensureHasDefault alts;
  --   alts.forM fun alt => do
  --     match alt with
  --     | Alt.ctor c b  => emit "case "; emit c.cidx; emitLn ":"; (emitFnBody b {})
  --     | Alt.default b => emitLn "default: "; (emitFnBody b {})
  --   emitLn "}"

-- | This emits a join point as a lz.joinpoint region
partial def emitJoinPointDecl (j : JoinPointId) (xs : Array Param) (inblock : FnBody)
  (rest : FnBody) (tys: HashMap VarId IRType) : M Unit := do
    emit ((escape "lz.joinpoint") ++ "()");
    emit "({\n";
    emit "^entry(";  
    xs.size.forM fun i => do
      if i > 0 then emit ", "
      let x := xs[i]
      emit "%"; emit x.x; emit ": "; emit (toCType x.ty)
    emit "):\n";
    let tysInBlock := xs.foldl (fun hashmap p => (hashmap.insert p.x p.ty)) tys
    emitBlock inblock tysInBlock;
    emit "}, {\n";
    emitBlock rest tys;
    emit "})";
    emitLn ": () -> ()";

-- | this emits a join point as a BB 
-- partial def emitJoinPointDecl (j : JoinPointId) (xs : Array Param) (inblock : FnBody)
--   (rest : FnBody) (tys: HashMap VarId IRType) : M Unit := do
--     emitBlock rest tys;
--     emit "^jp"; emit (toString j.idx); emit "(";  
--     xs.size.forM fun i => do
--       if i > 0 then emit ", "
--       let x := xs[i]
--       emit "%";
--       emit x.x;
--       emit ": ";
--       emit (toCType x.ty);
--     emit "):\n";
--     let tysInBlock := xs.foldl (fun hashmap p => (hashmap.insert p.x p.ty)) tys
--     emitBlock inblock tysInBlock

partial def emitBlock (b : FnBody) (tys: HashMap VarId IRType) : M Unit := do
  match b with
  -- TODO: join point
  | FnBody.jdecl j xs v b      => 
     emitLn "// ERR: fnBody.jdecl"
     emitJoinPointDecl j xs v b tys
  -- TODO: variable declaration
  | d@(FnBody.vdecl x t v b)   =>
    let tys  := tys.insert x t
    let ctx ← read
    if isTailCallTo ctx.mainFn d then
      emitLn "// ERR: fnBody.vdecl (tail call)";
      emitTailCall v tys
    else
      emitLn "//ERR: fnBody.vdecl (non-tail) call";
      emitVDecl x t v (tys.insert x t)
      emitBlock b (tys.insert x t)
  | FnBody.inc x n c p b       =>
    emitLn "// ERR: FnBody.inc "
    -- | p = persistent
    unless p do emitInc x n c
    emitBlock b tys
  | FnBody.dec x n c p b       =>
    emitLn "// ERR: FnBody.dec "
    -- | p = persistent
    unless p do emitDec x n c
    emitBlock  b tys
  | FnBody.del x b             => 
    panicM "// ERR: FnBody.del"; emitBlock b tys ; -- emitDel x; emitBlock b
  | FnBody.setTag x i b        => 
    panicM "// ERR: FnBody.setTag"; emitBlock b tys; -- emitSetTag x i; emitBlock b
  | FnBody.set x i y b         =>
    panicM "// ERR: FnBody.set"; emitBlock b  tys; -- emitSet x i y; emitBlock b
  | FnBody.uset x i y b        =>
    panicM "// ERR: FnBody.uset"; emitBlock b tys; -- emitUSet x i y; emitBlock b
  | FnBody.sset x i o y t b    =>
    panicM "// ERR: FnBody.sset"; emitBlock b tys; -- emitSSet x i o y t; emitBlock b
  | FnBody.mdata _ b           => emitBlock b tys
  | FnBody.ret x               =>
    emitLn "//ERR: FnBody.ret"
   -- emit "return "; emitArg x;
   -- TODO: switch to generic form of operation
    emit "lz.return "; emitArg x;
    emit " : ";  emitLn (toCType (lookupArgTy tys x));
  | FnBody.case _ x xType alts => do
    emitLn "// ERR: FnBody.case"
    emitCase x xType alts tys
  | FnBody.jmp j xs            => do
      emitLn "// ERR: FnBody.jmp"
      emitJmp j xs tys
  | FnBody.unreachable         => 
    emitLn "// ERR: FnBody.unreachable" -- emitLn "lean_internal_panic_unreachable();"

partial def emitJPs : FnBody → M Unit
  | FnBody.jdecl j xs v b => do emit j; emitLn ":"; 
                                emitFnBody v {} EmitIrrelevant.yes;
                                emitJPs b
  | e                     => do unless e.isTerminal do emitJPs e.body


-- | function to create a hash map of arguments introduced by this fnBody
partial def insertFnBodyArgTypes : FnBody → M (HashMap VarId IRType)
  | e@(FnBody.vdecl x t _ b), d => do
    -- TODO: I might not be doing this right, here! May have to follow
    -- the tail call?
    -- let ctx ← read
    -- if isTailCallTo ctx.mainFn e then
    --   pure d
    -- else
    -- declareVar x t; declareVars b true
    pure {}
  | FnBody.jdecl j xs _ b, d => do
    -- pure {}
    pure (xs.foldl (fun m p => (m.insert p.x p.ty)) {})
    -- declareParams xs; declareVars b (d || xs.size > 0)
  | e, d => pure {}




-- EmitIrrelevant is used to emit a value %irrelevant = ptr.undef 
-- at some regions, where we want to create a %irrelevant value that should be
-- in scope to emit an irrelevant argument. 
partial def emitFnBody (b : FnBody) (tys: HashMap VarId IRType)
   (irr: EmitIrrelevant): M Unit := do
  emitLn "{"
  match irr with
     | EmitIrrelevant.yes => 
        emitLn $ "%c0_irr = std.constant 0 : i64"
        emitLn $ "%irrelevant = call @lean_box(%c0_irr) : (i64) -> (!lz.value)"
     | EmitIrrelevant.no => pure ()
  let tys <- insertFnBodyArgTypes b
  emitBlock b tys
  emitLn "}"

end
  
-- called from emitFns -> emitDecl -> emitDeclAux
def emitDeclAux (d : Decl) : M Unit := do
  let dname <- toCName d.name
  emitLn ("// ERR: emitDeclAux ("  ++ dname ++ ") | isExtern?" ++ (format (Decl.isExtern d)))
  let env ← getEnv
  let (vMap, jpMap) := mkVarJPMaps d
  withReader (fun ctx => { ctx with jpMap := jpMap }) do
  -- | TODO: what does hasInitAttr guard against?
  -- unless (hasInitAttr env d.name) do
  do
    match d with
    | Decl.fdecl (f := f) (xs := xs) (type := t) (body := b) .. => do
      emitLn ("// ERR: emitDeclAux Decl.fdecl ("  ++ dname ++ ")")
      let baseName ← toCName f;
      -- if xs.size == 0 then -- TODO: what is this doing?
      --   emit "static " -- TODO: understand what this is doing
      emit "func ";
      -- emit (toCType t); emit " ";
      if xs.size > 0 then
        emit ("@" ++ (escape baseName));
        emit "(";
        if xs.size > closureMaxArgs && isBoxedName d.name then
          emit "lean_object** _args"
        else
          xs.size.forM fun i => do
            if i > 0 then emit ", "
            let x := xs[i]
            emit "%"; emit x.x; emit ": "; emit (toCType x.ty)
        emit ")"
        emit (" -> " ++ (toCType t))
      else -- [xs.size = 0]
        -- TODO: there is something super funky about this codegen here!
        -- In particular, I don't understand this __init__ invariant.
        emitLn ("@_init_" ++ baseName ++ "()" ++ " -> " ++ (toCType t))
        
      -- | Do not have args like this.
      -- if xs.size > closureMaxArgs && isBoxedName d.name then
      --   xs.size.forM fun i => do
      --     let x := xs[i]
      --     emit "lean_object* "; emit x.x; emit " = _args["; emit i; emitLn "];"
      -- emitLn "_start:";
      -- let tys :=  (xs.foldl (fun m p => (m.insert p.x p.ty)) {});
      withReader (fun ctx => { ctx with mainFn := f, mainParams := xs })
                 (emitFnBody b 
                             ((xs.foldl (fun m p => (m.insert p.x p.ty)) {}))
                             EmitIrrelevant.yes);
    | _ => emitLn "// ERR: unknwown decl"; pure ()

-- calle from emitFns
def emitDecl (d : Decl) : M Unit := do
  let d := d.normalizeIds; -- ensure we don't have gaps in the variable indices
  try
    emitDeclAux d
  catch err =>
    throw s!"{err}\ncompiling:\n{d}"
    panic s!"{err}\ncompiling:\n{d}"

def emitFns : M Unit := do
  let env ← getEnv;
  let decls := getDecls env;
  decls.reverse.forM emitDecl

-- def emitMarkPersistent (d : Decl) (n : Name) : M Unit := do
def emitMarkPersistent (d : Decl) (valueName : String) : M Unit := do
  if d.resultType.isObj then
    -- emit "lean_mark_persistent("; emitCName n; emitLn ");"
    emit "call @lean_mark_persistent(%"; emit valueName; emitLn ") : (!lz.value) -> ()"



def emitDeclInit (d : Decl) : M Unit := do
  let env ← getEnv
  let n := d.name
  emitLn $ "// ERR: emitDeclInit: (" ++ n ++ ")"
  if isIOUnitInitFn env n then
     let resIOName <- gensym "result"
     let worldName <- gensym "world"
    -- emit "res = "; emitCName n; emitLn "(lean_io_mk_world());"
     emitLn $ "%" ++ worldName ++ " = " ++ "@lean_io_mk_world() : () -> !lz.value"
     emit ("%" ++ resIOName ++ " = " ++ "call @"); emitCName n; emit "(%worldName)";
     emit " : (!lz.value) -> "; emit (toCType ∘ Decl.resultType $ d); emitLn "";
    -- emitLn "if (lean_io_result_is_error(res)) return res;"
    -- emitLn "lean_dec_ref(res);"
  else if d.params.size == 0 then
    match getInitFnNameFor? env d.name with
    | some initFn =>
          -- emit "res = "; emitCName initFn; emitLn "(lean_io_mk_world());"
          let resIOName <- gensym "result"
          let worldName <- gensym "world"
          emitLn $ "%" ++ worldName ++ " = " ++ "@lean_io_mk_world() : () -> !lz.value"
          emit ("%" ++ resIOName ++ " = " ++ "call @"); emitCName initFn; emit "(%worldName)";
          emit " : (!lz.value) -> "; emit (toCType ∘ Decl.resultType $ d); emitLn "";
          -- emitLn "if (lean_io_result_is_error(res)) return res;"
          -- emitCName n; emitLn " = lean_io_result_get_value(res);"
          let resValueName <- gensym "resultVal"
          emitLn $ "%" ++ resValueName ++ " = " ++ "std.call @lean_io_get_result_value(" ++ resIOName ++")"
          emit $ (escape "ptr.storeglobal"); 
          emit "(%";  emit resValueName; emit ")";
          emit "{value=@"; emitCName n; emit "}"
          emit ": ("; emit (toCType ∘ Decl.resultType $ d); emit ") -> ()"; emitLn "";
          -- emitMarkPersistent d n
          emitMarkPersistent d resValueName
          -- emitLn "lean_dec_ref(res);"
     | _ =>
          -- emitCName n; emit " = "; emitCInitName n; emitLn "();"; emitMarkPersistent d n
         let resName <- gensym "result";
         emit ("%" ++ resName ++ " = " ++ "call @"); emitCInitName n; emit "()";
         emit ": () -> "; emit (toCType ∘ Decl.resultType $ d); emitLn "";
         emit $ (escape "ptr.storeglobal"); emit "(%";  emit resName ; emit ")";
         emit "{value=@"; emitCName n; emit "}";
         emit " : ("; emit (toCType ∘ Decl.resultType $ d); emit  ") -> ()"; emitLn "";
         -- emitMarkPersistent d n
         emitMarkPersistent d resName

def emitInitFn : M Unit := do
  let env ← getEnv
  let modName ← getModName
  assertM "expected only one import" (env.imports.toList.length == 1)
    -- | TODO: figure out what this code is doing. As it is currently written,
  -- the C code makes no sense to me. It calls the initialization function on itself???
  -- I guess the difference is between modName and imp.module; I don't understand
  -- the difference.
  -- this FORWARD DECLARES the initialization for modules.
  env.imports.forM fun imp => do
    emitLn $ "func private @" ++ mkModuleInitializationFunctionName imp.module ++ 
       "(!lz.value) -> (!lz.value)"

  env.imports.forM fun imp => do
     -- emitLn $ " //ERR: initialization: (" ++ mkModuleInitializationFunctionName modName ++ ")"
     -- emit $ "func private @" ++ mkModuleInitializationFunctionName modName;
     -- | name of lean entrypoint
     emit $ "func private @" ++ "init_lean_custom_entrypoint_hack";
     emitLn "(%w :!lz.value) -> !lz.value {"
     let initResult <- gensym "initResult"
     let worldname <- gensym "world"
     emitLn $ "%" ++ worldname ++ " = call @lean_io_mk_world() : () -> (!lz.value)"
     -- | this CALLS the initialization function for MODULES
     emitLn $ "//ERR: initializing imp.module(" ++ (mkModuleInitializationFunctionName imp.module) ++ ")"
     emitLn ("%" ++ initResult  ++ " = " ++
       "call @" ++ mkModuleInitializationFunctionName imp.module ++ 
       "(" ++  "%" ++ worldname ++ ")" ++ 
       " : (!lz.value) -> !lz.value"
       )
     -- emitLn $ (escape "ptr.storeglobal") ++  "(){value=@" ++ 
     emitLn $ "call @lean_dec_ref(%" ++ initResult ++ ") : (!lz.value) -> ()"
    -- | done initing everyone -- |  
  -- | this CALLS the different DECLARATIONS in the file.
  let decls := getDecls env
  decls.reverse.forM emitDeclInit
    -- emitLns ["return lean_io_result_mk_ok(lean_box(0));", "}"]
  emitLn "%c0 = constant 0 : i64"
  emitLn "%box0 = call @lean_box(%c0) : (i64) -> !lz.value"
  emitLn "%out = call @lean_io_result_mk_ok(%box0) : (!lz.value) -> !lz.value"
  emitLn "return %out : !lz.value"
  emitLn "}"
 

def main : M Unit := do
  -- emitFileHeader
  emitPreamble
  emitFnFwdDecls
  emitFns
  emitInitFn
  -- emitMainFnIfNeeded
  -- emitFileFooter

end EmitMLIR

@[export lean_ir_emit_mlir]
def emitMLIR (env : Environment) (modName : Name) : Except String String :=
  let initState := { out := "", guid := 0  : EmitMLIR.State };
  match (EmitMLIR.main { env := env, modName := modName }).run initState with
  | EStateM.Result.ok    _   s => Except.ok s.out
  | EStateM.Result.error err _ => Except.error err

end Lean.IR
