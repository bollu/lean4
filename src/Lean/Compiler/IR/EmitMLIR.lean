/-
Copyright (c) 2019 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura
-/
import Lean.Runtime
import Lean.Compiler.NameMangling
import Lean.Compiler.ExportAttr
import Lean.Compiler.InitAttr
import Lean.Compiler.IR.CompilerM
import Lean.Compiler.IR.EmitUtil
import Lean.Compiler.IR.NormIds
import Lean.Compiler.IR.SimpCase
import Lean.Compiler.IR.Boxing
import Lean.Data.KVMap
import Init.Data.List

open Std (HashMap)

namespace Lean.IR.EmitMLIR

open ExplicitBoxing (requiresBoxedVersion mkBoxedName isBoxedName)

-- hack
-- def closureMaxArgs : Nat := 4200


-- | type of owner, is the parent a funcop or a caseop
inductive OwningBlockType where
  | funcop | caseop


inductive EmitIrrelevant where
  | yes | no

inductive IsTail where 
  | yes | no

-- def mkModuleInitializationFunctionName (moduleName : Name) : String :=



partial def lookupArgTy (tys: HashMap VarId IRType) (a: Arg) : IRType := 
  match a with 
  | Arg.var id => 
    match tys.find? id with
    | some ty => ty
    -- TODO: get stack trace? X(
    -- | Use IRType.union so we can see in the IR which value has missing types.
    -- | IRType.union is not generated by anything.
    | none =>  IRType.union "BOLLU_ERR_LookupArgTy".toName #[] --panic $ "unable to find type of arg"
  | Arg.irrelevant => IRType.irrelevant

def escape  {a : Type} [ToFormat a] : a -> Format
  | a => "\"" ++ format a ++ "\""



def leanMainFn := "main_lean_custom_entrypoint_hack"

structure Context where
  env        : Environment
  modName    : Name
  jpMap      : JPParamsMap := {}
  mainFn     : FunId := arbitrary
  mainParams : Array Param := #[]


structure State where
   out       : String := ""
   guid      : Nat := 0

   
-- need more state here to generate GUIDs
abbrev M := ReaderT Context (EStateM String State)

def assertM (s: String) (b: Bool) : M Unit := 
  if b
  then pure ()
  else do panic ("ASSERTION ERROR: " ++ s); pure ()


def panicM (s: String) : M Unit := do
  panic ("panic!: " ++ s); pure ()


def gensym (s: String) : M String := do
  -- let ix <- modifyGet (fun st => (ix, { st with guid := st.guid + 1}))
  let st <- get
  set ({ st with guid := st.guid + 1})
  pure ("G" ++ s ++ toString st.guid)
  

def getEnv : M Environment := Context.env <$> read
def getModName : M Name := Context.modName <$> read
def getDecl (n : Name) : M Decl := do
  let env ← getEnv
  match findEnvDecl env n with
  | some d => pure d
  | none   => throw s!"unknown declaration '{n}'"

@[inline] def emit {α : Type} [ToString α] (a : α) : M Unit :=
  modify fun st => { st with out := st.out ++ toString a }

@[inline] def emitLn {α : Type} [ToString α] (a : α) : M Unit := do
  emit a; emit "\n"

def emitI32 (name : String) (v: Nat) : M String := do
  let lhs <- gensym name;
  emitLn  $ "%" ++ lhs ++ " = " ++ "std.constant " ++ (toString v) ++ " : i32";
  return lhs;

def emitString (name : String) (v: String) : M String := do
  let lhs <- gensym name;
  emit  $ "%" ++ lhs ++ " = " ++ (escape "ptr.string ()");
  emitLn $ "{value=\"" ++ (toString v) ++ "\"} : () -> (!lz.value)"
  return lhs;


def emitLns {α : Type} [ToString α] (as : List α) : M Unit :=
  as.forM fun a => emitLn a

def argToCString (x : Arg) : String :=
  match x with
  | Arg.var x  => toString x
  | irrelevant => "irrelevant" -- "lean_box(0)"

def emitArg (x : Arg) : M Unit :=
  emit ("%" ++ (argToCString x))

def toCType : IRType → String
  | IRType.float      => "f64"
  | IRType.uint8      => "i8"
  | IRType.uint16     => "i16"
  | IRType.uint32     => "i32"
  | IRType.uint64     => "i32"
  | IRType.usize      => "i32" -- TODO: find some better way to encode size.
  | IRType.object     => "!lz.value" -- "lean_object*"
  | IRType.tobject    => "!lz.value" -- "lean_object*"
  | IRType.irrelevant => "!lz.value" -- "lean_object*"
  | IRType.struct _ _ => panic! "not implemented yet"
  | IRType.union name arrtys  => toString name
     -- if arrtys.toList.length == 0 -- from binarytrees.lean: errorLookupArgTy
     -- then "!lz.value"
     -- else panic! "not implemented yet" 

def throwInvalidExportName {α : Type} (n : Name) : M α :=
  throw s!"invalid export name '{n}'"

def toCName (n : Name) : M String := do
  let env ← getEnv;
  -- TODO: we should support simple export names only
  match getExportNameFor env n with
  | some (Name.str Name.anonymous s _) => pure s
  | some _                             => throwInvalidExportName n
  | none                               => if n == `main then pure leanMainFn else pure n.mangle

def emitCName (n : Name) : M Unit :=
  toCName n >>= emit


def toCInitName (n : Name) : M String := do
  let env ← getEnv;
  -- TODO: we should support simple export names only
  match getExportNameFor env n with
  | some (Name.str Name.anonymous s _) => pure $ "_init_" ++ s
  | some _                             => throwInvalidExportName n
  | none                               => pure ("_init_" ++ n.mangle)


def emitCInitName (n : Name) : M Unit :=
  toCInitName n >>= emit
 
-- called from emitFnFwdDecls -> emitFnFwdDecl
def emitFnFwdDeclAux (decl : Decl) (cppBaseName : String) (addExternForConsts : Bool) : M Unit := do
  emitLn $ "// ERR: emitFnFwdDeclAux (" ++ cppBaseName ++ ")"
  let ps := decl.params
  let env ← getEnv
  if ps.isEmpty
  then do
    emit (escape "ptr.global"); emit "()";
    emit $ "{value=@" ++ cppBaseName ++ ", type=" ++ (toCType decl.resultType) ++ "}";
    emitLn $ " : " ++  "() -> ()"; -- emit (toCType decl.resultType); emitLn "";
  else do
    emit ("func private @" ++ cppBaseName)
    emit "("
    -- We omit irrelevant parameters for extern constants
    let ps := if isExternC env decl.name then ps.filter (fun p => !p.ty.isIrrelevant) else ps
    if ps.size > closureMaxArgs && isBoxedName decl.name then
      emit "UNKNOWN_CASE_CLOSURE_MAX_ARGS"
      -- emit "lean_object**"
    else
      ps.size.forM fun i => do
        if i > 0 then emit ", "
        emit (toCType ps[i].ty)
    emit ")"
    emitLn (" -> " ++ (toCType decl.resultType))
 
-- called from emitFnDecls -> emitFnDecl
def emitFnFwdDecl (decl : Decl) (addExternForConsts : Bool) : M Unit := do
  emitLn "// ERR: emitFnFwdDecl"
  let cppBaseName ← toCName decl.name
  emitFnFwdDeclAux decl cppBaseName addExternForConsts

def emitExternFwdDeclAux (decl : Decl) (cNameStr : String) : M Unit := do
  let env ← getEnv
  let extC := isExternC env decl.name
  emitFnFwdDeclAux decl cNameStr (!extC)

def emitFnFwdDecls : M Unit := do
  let env ← getEnv
  let decls := getDecls env
  let modDecls  : NameSet := decls.foldl (fun s d => s.insert d.name) {}
  let usedDecls : NameSet := decls.foldl (fun s d => collectUsedDecls env d (s.insert d.name)) {}
  let usedDecls := usedDecls.toList
  usedDecls.forM fun n => do
    let decl ← getDecl n;
  --   if Decl.isExtern decl 
  --   then emitExternDeclAux decl cname
  --   else pure ()
    match getExternNameFor env `c decl.name with
    | some cName => do
            emitExternFwdDeclAux decl cName
   -- THIS IS DELICATE. We need forward declarations for GLOBALS, and not for
   -- FUNCTIONS. I can't forward declare functions because MLIR has stupid rules
   -- about redefining symbols (!). 
   -- So we check if it is a global. If it is, we spit out a forward
   -- declaration. If not, we do not.
    | none       => if decl.params.isEmpty -- is a global
                    then emitFnFwdDecl decl (!modDecls.contains n)
                    else if modDecls.contains n -- is a function declared in the module
                    then  pure ()
                    -- | is a function, NOT declared in the module
                    else emitFnFwdDecl decl (!modDecls.contains n)

-- def emitMainFn : M Unit := do
--   let d ← getDecl `main
--   match d with
--   | Decl.fdecl (f := f) (xs := xs) (type := t) (body := b) .. => do
--     unless xs.size == 2 || xs.size == 1 do throw "invalid main function, incorrect arity when generating code"
--     let env ← getEnv
--     let usesLeanAPI := usesModuleFrom env `Lean
--     if usesLeanAPI then
--        emitLn "void lean_initialize();"
--     else
--        emitLn "void lean_initialize_runtime_module();";
--     emitLn "
--   #if defined(WIN32) || defined(_WIN32)
--   #include <windows.h>
--   #endif
--  
--   int main(int argc, char ** argv) {
--   #if defined(WIN32) || defined(_WIN32)
--   SetErrorMode(SEM_FAILCRITICALERRORS);
--   #endif
--   lean_object* in; lean_object* res;";
--     if usesLeanAPI then
--       emitLn "lean_initialize();"
--     else
--       emitLn "lean_initialize_runtime_module();"
--     let modName ← getModName
--     emitLn ("res = " ++ mkModuleInitializationFunctionNameHACK modName ++ "(lean_io_mk_world());")
--     emitLns ["lean_io_mark_end_initialization();",
--              "if (lean_io_result_is_ok(res)) {",
--              "lean_dec_ref(res);",
--              "lean_init_task_manager();"];
--     if xs.size == 2 then
--       emitLns ["in = lean_box(0);",
--                "int i = argc;",
--                "while (i > 1) {",
--                " lean_object* n;",
--                " i--;",
--                " n = lean_alloc_ctor(1,2,0); lean_ctor_set(n, 0, lean_mk_string(argv[i])); lean_ctor_set(n, 1, in);",
--                " in = n;",
--               "}"]
--       emitLn ("res = " ++ leanMainFn ++ "(in, lean_io_mk_world());")
--     else
--       emitLn ("res = " ++ leanMainFn ++ "(lean_io_mk_world());")
--     emitLn "}"
--     emitLns ["if (lean_io_result_is_ok(res)) {",
--              "  int ret = lean_unbox(lean_io_result_get_value(res));",
--              "  lean_dec_ref(res);",
--              "  return ret;",
--              "} else {",
--              "  lean_io_result_show_error(res);",
--              "  lean_dec_ref(res);",
--              "  return 1;",
--              "}"]
--     emitLn "}"
--   | other => throw "function declaration expected"
--  
-- def hasMainFn : M Bool := do
--   let env ← getEnv
--   let decls := getDecls env
--   pure $ decls.any (fun d => d.name == `main)
--  
-- def emitMainFnIfNeeded : M Unit := do
--   if (← hasMainFn) then emitMainFn

-- Prelude
-- emitPrelude
def emitPreamble : M Unit := do
  let env ← getEnv
  let modName ← getModName
  emitLn "// Lean compiler output"
  emitLn ("// Module: " ++ toString modName)
  emit "// Imports:"
  env.imports.forM fun m => emit (" " ++ toString m); emitLn ""
  emitLn "func private @lean_unbox_float(!lz.value) -> f64"
  emitLn "func private @lean_unbox_uint8(!lz.value) -> i8"
  emitLn "func private @lean_unbox_uint16(!lz.value) -> i16"
  emitLn "func private @lean_unbox_uint32(!lz.value) -> i32"
  emitLn "func private @lean_unbox_uint64(!lz.value) -> i32"
  emitLn "func private @lean_unbox_usize(!lz.value) -> i32"
  emitLn "func private @lean_unbox(!lz.value) -> i8"

  emitLn "func private @lean_inc(!lz.value) -> ()"
  emitLn "func private @lean_inc_n(!lz.value, i32) -> ()"
  emitLn "func private @lean_inc_ref(!lz.value) -> ()"

  emitLn "func private @lean_ctor_set(!lz.value, i32, !lz.value) -> ()"

  emitLn "func private @lean_dec(!lz.value) -> ()"
  emitLn "func private @lean_dec_n(!lz.value, i32) -> ()"
  emitLn "func private @lean_dec_ref(!lz.value) -> ()"

  emitLn "func private @lean_is_exclusive(!lz.value) -> (i1)"
  emitLn "func private @lean_is_scalar(!lz.value) -> (i1)"
  

  emitLn "func private @lean_io_mk_world() -> (!lz.value)"
  emitLn "func private @lean_initialize() -> ()"
  emitLn "func private @lean_io_result_get_value(!lz.value) -> (!lz.value)"
  emitLn "func private @lean_io_result_mk_ok(!lz.value) -> (!lz.value)"
  emitLn "func private @lean_mark_persistent(!lz.value) -> ()"

  emitLn "func private @lean_box_float(f64) -> (!lz.value)"
  emitLn "func private @lean_box_uint8(i8) -> (!lz.value)"
  emitLn "func private @lean_box_uint16(i16) -> (!lz.value)"
  emitLn "func private @lean_box_uint32(i32) -> (!lz.value)"
  emitLn "func private @lean_box_uint64(i32) -> (!lz.value)"
  emitLn "func private @lean_box_usize(i464) -> (!lz.value)"
  emitLn "func private @lean_box(i32) -> !lz.value"

  emitLn "func private @lean_ctor_get_float(!lz.value, i32) -> (f64)"
  emitLn "func private @lean_ctor_get_uint8(!lz.value, i32) -> (i8)"
  emitLn "func private @lean_ctor_get_uint16(!lz.value, i32) -> (i16)"
  emitLn "func private @lean_ctor_get_uint32(!lz.value, i32) -> (i32)"
  emitLn "func private @lean_ctor_get_uint64(!lz.value, i32) -> (i32)"


  emitLn "func private @lean_ctor_set_float(!lz.value, i32, f64) -> ()"
  emitLn "func private @lean_ctor_set_uint8(!lz.value, i32, i8) -> ()"
  emitLn "func private @lean_ctor_set_uint16(!lz.value, i32, i16) -> ()"
  emitLn "func private @lean_ctor_set_uint32(!lz.value, i32, i32) -> ()"
  emitLn "func private @lean_ctor_set_uint64(!lz.value, i32, i32) -> ()"

  emitLn "func private @lean_alloc_ctor(i32, i32, i32) -> (!lz.value)"
  emitLn "func private @lean_ctor_release(!lz.value, i32) -> ()"
  emitLn "func private @lean_ctor_set_tag(!lz.value, i32) -> ()"

  emitLn "func private @lean_cstr_to_nat(!lz.value) -> (!lz.value)"
  -- emitLn "func private @lean_uint32_eq(i32, i32) -> (i8)"

  emitLn "func private @lean_free_object(!lz.value) -> ()"

def emitFileHeader : M Unit := do
  let env ← getEnv
  let modName ← getModName
  emitLn "// Lean compiler output"
  emitLn ("// Module: " ++ toString modName)
  emit "// Imports:"
  env.imports.forM fun m => emit (" " ++ toString m)
  emitLn ""
  emitLn "#include <lean/lean.h>"
  emitLns [
    "#if defined(__clang__)",
    "#pragma clang diagnostic ignored \"-Wunused-parameter\"",
    "#pragma clang diagnostic ignored \"-Wunused-label\"",
    "#elif defined(__GNUC__) && !defined(__CLANG__)",
    "#pragma GCC diagnostic ignored \"-Wunused-parameter\"",
    "#pragma GCC diagnostic ignored \"-Wunused-label\"",
    "#pragma GCC diagnostic ignored \"-Wunused-but-set-variable\"",
    "#endif",
    "#ifdef __cplusplus",
    "extern \"C\" {",
    "#endif"
  ]

def emitFileFooter : M Unit :=
  emitLns [
   "#ifdef __cplusplus",
   "}",
   "#endif"
  ]

def throwUnknownVar {α : Type} (x : VarId) : M α :=
  throw s!"unknown variable '{x}'"

def getJPParams (j : JoinPointId) : M (Array Param) := do
  let ctx ← read;
  match ctx.jpMap.find? j with
  | some ps => pure ps
  | none    => throw "unknown join point"

def declareVar (x : VarId) (t : IRType) : M Unit := do
  emit (toCType t); emit " "; emit x; emit "; "

def declareParams (ps : Array Param) : M Unit :=
  ps.forM fun p => declareVar p.x p.ty



partial def declareVars : FnBody → Bool → M Bool
  | e@(FnBody.vdecl x t _ b), d => do
    let ctx ← read
    if isTailCallTo ctx.mainFn e then
      pure d
    else
      declareVar x t; declareVars b true
  | FnBody.jdecl j xs _ b,    d => do declareParams xs; declareVars b (d || xs.size > 0)
  | e,                        d => if e.isTerminal then pure d else declareVars e.body d

def emitTag (x : VarId) (xType : IRType) : M Unit := do
  if xType.isObj then do -- TODO: steal for case v/s caseInt
    emit "lean_obj_tag("; emit x; emit ")"
  else
    emit x

def isIf (alts : Array Alt) : Option (Nat × FnBody × FnBody) :=
  if alts.size != 2 then none
  else match alts[0] with
    | Alt.ctor c b => some (c.cidx, b, alts[1].body)
    | _            => none

-- def emitInc (x : VarId) (n : Nat) (checkRef : Bool) : M Unit := do
--  emit $
--    if checkRef then (if n == 1 then "lean_inc" else "lean_inc_n")
--    else (if n == 1 then "lean_inc_ref" else "lean_inc_ref_n")
--  emit "("; emit x
--  if n != 1 then emit ", "; emit n

-- def emitInc (x : VarId) (n : Nat) (checkRef : Bool) : M Unit := do
--   let nname <- gensym "n"
--   emitLn $ "%" ++ nname ++ " = std.constant " ++ (toString n) ++ " : i32"
--   emit "call ";
--   emit $
--      if checkRef then "@lean_inc_n"
--      else  "@lean_inc_ref_n"
--   emit "("; emit "%"; emit x
--   emitLn $ ", %" ++ nname ++ ") : (!lz.value, i32) -> ()"

def emitInc (x : VarId) (n : Nat) (checkRef : Bool) : M Unit := do
  emit $ (escape "lz.inc") ++ "(%"; emit x; emitLn $  ") {value=" ++ (toString n) ++ ", checkref=" ++ (toString checkRef) ++ "} : (!lz.value) -> ()"


-- def emitDec (x : VarId) (n : Nat) (checkRef : Bool) : M Unit := do
--   if n != 1 then panicM "there is no lean_dec for more than 1 parameter"
--   let nv <- emitI32 "n" n;
--   emit $ "call " ++ (if checkRef then "@lean_dec" else "@lean_dec_ref");
--   emit "(%"; emit x; emitLn ") : (!lz.value) -> ()"

def emitDec (x : VarId) (n : Nat) (checkRef : Bool) : M Unit := do
  emit $ (escape "lz.dec") ++ "(%"; emit x; emitLn $  ") {value=" ++ (toString n) ++ ", ref=" ++ (toString checkRef) ++ "} : (!lz.value) -> ()"

def emitDel (x : VarId) : M Unit := do
  emit "call @lean_free_object(%"; emit x; emitLn ") : (!lz.value) -> ()"

def emitSetTag (x : VarId) (i : Nat) : M Unit := do
  let iv <- emitI32 "i" i;
  emit "call @lean_ctor_set_tag(%"; emit x; emit ", %"; emit iv; emit ")";
  emitLn $ " : (!lz.value, i32) -> ()"

def emitSet (x : VarId) (i : Nat) (y : Arg) : M Unit := do
  let ix <- emitI32 "ix" i; 
  emit "call @lean_ctor_set(%"; emit x; emit ", %"; emit ix;
  emit ", "; emitArg y; emit ")"
  emitLn $ " : (!lz.value, i32, !lz.value) -> ()"

def emitOffset (n : Nat) (offset : Nat) : M String := do
  let SIZEOF_VOIDPTR := 8; -- this is the janky bit.
  let out <- emitI32 "offset" ((SIZEOF_VOIDPTR*n) + offset)
  emitLn $ " // n=" ++ toString n ++ " | offset=" ++ toString offset 
  return out;
  -- if n > 0 then
  --   emit "sizeof(void*)*"; emit n;
  --   if offset > 0 then emit " + "; emit offset
  -- else
  --  emit offset

def emitLhs (z : VarId) : M Unit := do
  emit "%"; emit z; emit " = "

-- | emit the type of the argument
def emitArgTy (a: Arg) (tys: HashMap VarId IRType) : M Unit :=  do
    emit (toCType (lookupArgTy tys a));

-- | emit the tpe of a variable
def emitVarTy (v: VarId) (tys: HashMap VarId IRType) : M Unit :=  do
    emit (toCType (lookupArgTy tys (mkVarArg v)));



-- | TODO: what is this for?
def emitUSet (x : VarId) (n : Nat) (y : VarId) : M Unit := do
  -- let nname <- gensym "n";
  -- emitLn $  "%" ++ nname ++ " = std.constant " ++ (toString n) ++ " i32"
  let nv <- emitI32 "n" n
  emit "@lean_ctor_set_usize(%"; emit x; emit ", "; 
  emit "%"; emit nv; emit ", ";
  emit "%"; emit y; emitLn ") : (!lz.value, i32, !lz.value) -> ()"

 /- Store `y : ty` at Position `sizeof(void*)*i + offset` in `x`. `x` must be a Constructor object and `RC(x)` must be 1.
    `ty` must not be `object`, `tobject`, `irrelevant` nor `Usize`.
  | sset (x : VarId) (i : Nat) (offset : Nat) (y : VarId) (ty : IRType) (b : FnBody)
 -/
def emitSSet (x : VarId) (n : Nat) (offset : Nat) (y : VarId) (t : IRType) (tys: HashMap VarId IRType): M Unit := do
  let ix <- emitOffset n offset
  emit "call ";
  match t with
  | IRType.float  => emit "@lean_ctor_set_float"
  | IRType.uint8  => emit "@lean_ctor_set_uint8"
  | IRType.uint16 => emit "@lean_ctor_set_uint16"
  | IRType.uint32 => emit "@lean_ctor_set_uint32"
  | IRType.uint64 => emit "@lean_ctor_set_uint64"
  | _             => throw $ "invalid SSet (" ++ toString x ++ " : " ++ toString t ++ ")";
  -- emit "("; emit x; emit ", "; emitOffset n offset; emit ", "; emit y; emitLn ");"
  emit "(%"; emit x; emit ", %"; emit ix; emit ", %"; emit y; emit ")";
  emit " : ("; emitVarTy x tys; emit ", i32, ";  emitVarTy y tys; emitLn ") -> ()"; 

-- | emit args with types interleaved
def emitArgsInterleavedTys (ys: Array Arg) (tys: HashMap VarId IRType) : M Unit :=
  ys.size.forM fun i => do
    if i > 0 then emit ", "
    emitArg ys[i];
    emit " : ";
    emitArgTy ys[i] tys

-- | emit only the types of the arguments
def emitArgsOnlyTys (ys: Array Arg) (tys: HashMap VarId IRType) : M Unit :=
  ys.size.forM fun i => do
    if i > 0 then emit ", "
    emit (toCType (lookupArgTy tys ys[i]));


def emitArgs (ys : Array Arg) : M Unit :=
  ys.size.forM fun i => do
    if i > 0 then emit ", "
    emitArg ys[i]


-- | this emits a jmp as a lz instruction
def emitJmp (j : JoinPointId) (xs : Array Arg)
  (tys: HashMap VarId IRType) : M Unit := do
  -- let ps ← getJPParams j
  -- unless xs.size == ps.size do throw "invalid goto"
  emit (escape "lz.jump"); emit "(";
  xs.size.forM fun i => do
    -- let p := ps[i]
    let x := xs[i]
    if i > 0 then emit ", ";
    emitArg xs[i];
  emit $ "){value=" ++ (toString j.idx) ++  "}";
  emit ": ("; emitArgsOnlyTys  xs tys; emit ")"; emitLn " -> ()";

-- | this emits a jmp as a LLVM branch 
-- def emitJmp (j : JoinPointId) (xs : Array Arg)
--   (tys: HashMap VarId IRType) : M Unit := do
--   -- let ps ← getJPParams j
--   -- unless xs.size == ps.size do throw "invalid goto"
--   emit "br "; emit ("^jp" ++ (toString j.idx)); emit "(";
--   xs.size.forM fun i => do
--     -- let p := ps[i]
--     let x := xs[i]
--     if i > 0 then emit ", ";
--     emitArg xs[i]; emit " : "; emit (toCType (lookupArgTy tys x));
--   emitLn ")";



def emitCtorScalarSize (usize : Nat) (ssize : Nat) : M String := do
  let SIZEOF_VOIDPTR := 8; -- dodgy as fuck
  -- if usize == 0 then emitI32 "scalarSize" ssize;
  --- else if ssize == 0 then emitI32 "scalarSize" (SIZEOF_VOIDPTR; 
  -- else 
  let out <- emitI32 "scalarSize" ((SIZEOF_VOIDPTR * usize) + ssize); 
  emitLn $ "// CtorScalarSize: usize=" ++ (toString usize) ++ " | ssize=" ++ (toString ssize)
  return out;

def emitAllocCtor (c : CtorInfo) (out: String): M Unit := do
  let idxName <- emitI32 "cidx" c.cidx
  let csize <- emitI32 "csize" c.size
  let scalarSize <- emitCtorScalarSize c.usize c.ssize;
  emit $ "%" ++ out ++ " = "; 
  emit "call @lean_alloc_ctor(%"; emit idxName; emit ", %"; emit csize; emit ", ";
  emit "%"; emit scalarSize; emitLn ") : (i32, i32, i32) -> !lz.value"

-- def emitCtorSetArgs (z : VarId) (ys : Array Arg) : M Unit :=
--   ys.size.forM fun i => do
--     emit "lean_ctor_set("; emit z; emit ", "; emit i; emit ", "; emitArg ys[i]; emitLn ");"

def emitCtorSetArgs (z : VarId) (ys : Array Arg) : M Unit := 
  ys.size.forM fun i => do
    let ix <- emitI32 "ix" i;
    emit "call @lean_ctor_set(%"; emit z; emit ",";
    emit " %"; emit ix; emit ",";
    emitArg ys[i]; emitLn ") : (!lz.value, i32, !lz.value) -> ()"

-- | this is literally emitCtor
-- | TODO: raise to a higher abstraction level. Generate !lz.construct()
-- instead of the raw calls. 
-- For now, generate the raw calls to check that can lower correctly?
def emitExprCtor (z : VarId) (c : CtorInfo) (ys : Array Arg)
  (tys: HashMap VarId IRType): M Unit := do
  emitLhs z;
  emit (escape "lz.construct"); 
  emit "("; emitArgs ys;  emit ")";
  emit "{dataconstructor = @"; emit (escape c.cidx); emit  (", size=" ++ (toString c.size) ++ "}");
  emit " : ";
  emit "("; emitArgsOnlyTys ys tys; emitLn ") -> (!lz.value)";
  -- if c.size == 0 && c.usize == 0 && c.ssize == 0 then do
  --   let idxName <- gensym "idx";
  --   emit $ "%" ++ idxName ++ " = " ++ "constant " ++ (format c.cidx) ++ " : i32";
  --   emit "call @lean_box("; emit ("%" ++ idxName); emit ");"
  --   emit " : (i32) -> !lz.value"; emitLn "";
  -- else do
  --   emitAllocCtor c; emitCtorSetArgs z ys


-- def emitReset (z : VarId) (n : Nat) (x : VarId) : M Unit := do
--   emit "if (lean_is_exclusive("; emit x; emitLn ")) {";
--   n.forM fun i => do
--     emit " lean_ctor_release("; emit x; emit ", "; emit i; emitLn ");"
--   emit " "; emitLhs z; emit x; emitLn ";";
--   emitLn "} else {";
--   emit " lean_dec_ref("; emit x; emitLn ");";
--   emit " "; emitLhs z; emitLn "lean_box(0);";
--   emitLn "}"

def emitReset (z : VarId) (n : Nat) (x : VarId) (tys: HashMap VarId IRType): M Unit := do
  -- emit "if (lean_is_exclusive("; emit x; emitLn ")) {";
  let excl <- gensym "excl"
  emitLn $ "%" ++ (toString excl) ++ " = " ++ 
    "call @lean_is_exclusive(%" ++ (toString x) ++ ") : (!lz.value) -> (i1)"
  emitLhs z; emit " scf.if "; emit ("%" ++  excl); emitLn " -> (!lz.value) {";
  n.forM fun i => do
    let ci <- emitI32 "ix" i
    emit "call @lean_ctor_release(%"; emit x; emit ", %"; emit ci; emitLn ") : (!lz.value, i32 ) -> ()"
  emitLn $ "scf.yield %" ++ (toString x) ++ " : !lz.value";
  emitLn "} else {";
  emit " call @lean_dec_ref(%"; emit x; emitLn ") : (!lz.value) -> ()";
  let c0 <- emitI32 "c0" 0
  let c0box <- gensym "c0box";
  emitLn $ "%" ++ c0box ++ " = call @lean_box(%" ++ c0 ++ ") : (i32) -> (!lz.value)"
  emitLn $ " scf.yield %" ++ c0box ++ " : !lz.value"
  emitLn "}"


-- def emitReuse (z : VarId) (x : VarId) (c : CtorInfo) (updtHeader : Bool) (ys : Array Arg) (tys: HashMap VarId IRType): M Unit := do
--   emit "if (lean_is_scalar("; emit x; emitLn ")) {";
--   emit " "; emitLhs z; emitAllocCtor c;
--   emitLn "} else {";
--   emit " "; emitLhs z; emit x; emitLn ";";
--   if updtHeader then emit " lean_ctor_set_tag("; emit z; emit ", "; emit c.cidx; emitLn ");"
--   emitLn "}";
--   emitCtorSetArgs z ys


def emitReuse (z : VarId) (x : VarId) (c : CtorInfo) (updtHeader : Bool) (ys : Array Arg) (tys: HashMap VarId IRType): M Unit := do
  --  emit "if (lean_is_scalar("; emit x; emitLn ")) {";
  let isScalar <- gensym "scalar"
  emitLn $ "%" ++ (toString isScalar) ++ " = " ++ 
    "call @lean_is_scalar(%" ++ (toString x) ++ ") : (!lz.value) -> (i1)"
  emitLhs z; emit " scf.if "; emit ("%" ++  isScalar); emitLn " -> (!lz.value) {";
  let ctor <- gensym "ctor";
  emitAllocCtor c ctor
  emitLn $ "scf.yield %" ++ ctor ++ ": !lz.value"
  emitLn "} else {";
  -- emit " "; emitLhs z; emit x; emitLn ";";
  -- if updtHeader then emit " lean_ctor_set_tag("; emit z; emit ", "; emit c.cidx; emitLn ");"
  if updtHeader then (do
    let idx <- emitI32 "idx" c.cidx
    emit "call @lean_ctor_set_tag(%"; emit x;
    emit ", %"; emit idx; emitLn ") : (!lz.value, i32) -> ()";)
  emit "scf.yield %"; emit x; emitLn ": !lz.value"
  emitLn "}";
  emitCtorSetArgs z ys


def emitProj (z : VarId) (i : Nat) (x : VarId) (tys: HashMap VarId IRType): M Unit := do
  emitLhs z; emit (escape "lz.project");
  emit "("; emit "%"; emit x; emit ")"; 
  emit "{value="; emit i; emit "}";
  emit ":"; emit "("; emitVarTy x tys; emit ")"; emit "  -> ";
  emit "("; emitVarTy z tys; emit ")"; emitLn "";

-- | Pretty sure that has not been called so far.
-- | TODO: this remains untested!
def emitUProj (z : VarId) (i : Nat) (x : VarId) : M Unit := do
  panicM "unimplemented emitUProj"
  emitLhs z; emit "lean_ctor_get_usize("; emit x; emit ", "; emit i; emitLn ");"

--  /- Extract the scalar value at Position `sizeof(void*)*n + offset` from `x`. -/
--  sproj (n : Nat) (offset : Nat) (x : VarId)
def emitSProj (z : VarId) (t : IRType) (n offset : Nat) (x : VarId) (tys: HashMap VarId IRType): M Unit := do
  let ix <- emitOffset n offset;
  emitLhs z;
  emit "call ";
  match t with
  | IRType.float  => emit "@lean_ctor_get_float"
  | IRType.uint8  => emit "@lean_ctor_get_uint8"
  | IRType.uint16 => emit "@lean_ctor_get_uint16"
  | IRType.uint32 => emit "@lean_ctor_get_uint32"
  | IRType.uint64 => emit "@lean_ctor_get_uint64"
  | _             => throw "invalid instruction"
  emit "(%"; emit x; emit ", %"; emit ix; emit ")";
  emit " : ("; emitVarTy x tys; emit ", i32) -> ("; emit (toCType t); emitLn ")";

def toStringArgs (ys : Array Arg) : List String :=
  ys.toList.map argToCString


-- | ps: description of formal parameters to the function f.
def emitSimpleExternalCall (f : String) (ps : Array Param) (ys : Array Arg)
  (tys: HashMap VarId IRType) (retty: IRType) : M Unit := do
  -- let fname <- toCName f; -- added by bollu
  let fname := f;
  emit "call "; emit "@"; emit (escape fname)
  -- We must remove irrelevant arguments to extern calls
  let psys := (ps.zip ys).filter (fun py => not (py.fst.ty.isIrrelevant))
  let ys := Array.map Prod.snd psys

  emit "("
  -- We must remove irrelevant arguments to extern calls.
  ys.size.forM (fun i => do
         if i > 0 then emit ", ";
         emitArg ys[i])
  emit ")"
  -- TODO: understand why the line
  --    emit " : ("; emitArgsOnlyTys ys tys; emit ")";
  -- does not work!!!!
  emit " : ("; 
  psys.size.forM (fun i => do
    if i > 0 then emit ","
    emit (toCType psys[i].fst.ty);
  )
  emit ")";

  emit " -> "; emit "(";  emit (toCType retty);  emit ")";
  emit " // <== ERR: emitSimpleExternalCall";
  emit $ " // <== ys: " ++ toString (toStringArgs ys) ++ "| tys: ";
  emit "\n"
  pure ()


def emitExternCall (f : FunId)
                   (ps : Array Param)
                   (extData : ExternAttrData)
                   (ys : Array Arg)      
                   (tys: HashMap VarId IRType)
                   (retty: IRType) : M Unit := do
   match getExternEntryFor extData `c with
  | some (ExternEntry.standard _ extFn) => do
         emitSimpleExternalCall extFn ps ys tys retty
         emitLn "// ^^ ERR: ExternEntry.standard"; 
  | some (ExternEntry.inline name pat)     => do 
         emit (expandExternPattern pat (toStringArgs ys)); emitLn ";"
         emitLn $ "//^^ ERR: ExternEntry.inline [f: " ++ f ++ "|name: " ++ name ++ "|pat: " ++ pat ++ "]"; 

  | some (ExternEntry.foreign _ extFn)  => do
         emitSimpleExternalCall extFn ps ys tys retty
         emitLn "// ^^ ERR: ExternEntry.foreign"; 
  | _ => throw s!"failed to emit extern application '{f}'"


def emitFullApp  (f : FunId) (ys : Array Arg) (tys: HashMap VarId IRType) (tail: IsTail): M Unit := do
  let decl ← getDecl f
  match decl with
  | Decl.extern _ ps _ extData => do        
         emitExternCall f ps extData ys tys (Decl.resultType decl)
         emitLn "// ^^^ ERR: emitFullApp (Decl.extern)"
  | _ => do
    if ys.size == 0
    then
      -- let declAddr <- gensym "declAddr";
      -- -- %0 = llvm.mlir.addressof @const : !llvm.ptr<i32>
      -- emit ("%" ++ declAddr); emit " = "; emit "llvm.mlir.addressof";
      -- emit "@";
      -- let cname <-  toCName f
      -- emit (escape cname);
      -- emit " : "; emit "!llvm.ptr<"; emit (toCType (Decl.resultType decl));  emitLn ">"; 
      -- --   %1 = llvm.load %0 : !llvm.ptr<i32>
      -- emitLhs z; emit "llvm.load "; emit ("%" ++ declAddr);
      -- emit " : "; emit "!llvm.ptr<"; emit (toCType (Decl.resultType decl));  emitLn ">"

      emit (escape "ptr.loadglobal"); emit "()";
      let cname <- toCName f; 
      emit "{value=@"; emit (escape cname); emit "}";
      emit " : () -> ";emit (toCType (Decl.resultType decl));
      emitLn "// <== ERR: emitFullApp (pointer)"
      emitLn "";
    else 
      emit (escape "lz.call");
      let cname <-  toCName f
      -- emit $ "@" ++ (escape cname) ++ " ";
      emit "("; emitArgs ys; emit ")" 
      emit $ "{value=@" ++ (escape cname);
      match tail with 
       | IsTail.yes => emit ", musttail=\"true\"}";
       | IsTail.no => emit ", musttail=\"false\"}";
      emit ":"; emit "("; emitArgsOnlyTys ys tys; emit ")"
      emit "->"
      emit "(";  emit (toCType (Decl.resultType decl)); emit ")"
      emitLn "// <== ERR: emitFullApp (fncall)"
      emit "\n"



--  create a new pap
-- | Need to generate the arity correctly, this is fucked x(
-- def emitPartialApp (z : VarId) (f : FunId) (ys : Array Arg) : M Unit := do
--   let decl ← getDecl f
--   let arity := decl.params.size;
--   emitLhs z; emit "lean_alloc_closure((void*)("; emitCName f; emit "), "; emit arity; emit ", "; emit ys.size; emitLn ");";
--   ys.size.forM fun i => do
--     let y := ys[i]
--     emit "lean_closure_set("; emit z; emit ", "; emit i; emit ", "; emitArg y; emitLn ");"

-- TODO: what is the difference between pap and papm? In particular,
-- what are these CLOSURE_MAX_ARGS thing?
def emitPartialApp (z : VarId) (f : FunId)
  (ys : Array Arg) (tys: HashMap VarId IRType): M Unit := do
  let decl ← getDecl f
  let arity := decl.params.size;
  emitLhs z; 
  emitLn $ "// PAP ARITY: " ++ (toString decl.params.size) ++ " | num_fixed: " ++ toString ys.size;
  emit (escape "lz.pap"); emit "("; emitArgs ys; emit ") ";
  emit "{value=@"; emitCName f; emit $ ", arity=" ++ (toString arity) ++ "} ";
  emit " : "; emit "("; emitArgsOnlyTys ys tys; emit ")"; emitLn " -> (!lz.value)";
  -- emit "lean_alloc_closure((void*)("; emitCName f; emit "), ";
  -- emit arity; emit ", "; emit ys.size; emitLn ");";
  -- ys.size.forM fun i => do
  --   let y := ys[i]
  --   emit "lean_closure_set("; emit z; emit ", "; emit i; emit ", "; emitArg y; emitLn ");"

-- | this is the thing that extends an application
def emitApp (z : VarId) (f : VarId) (ys : Array Arg) (tys: HashMap VarId IRType): M Unit :=
  if ys.size > closureMaxArgs then do
    -- emit "{ lean_object* _aargs[] = {"; emitArgs ys; emitLn "};";
    -- emitLhs z; emit "lean_apply_m("; emit f; emit ", "; emit ys.size; emitLn ", _aargs); }"
    -- TODO: what is the difference between pap and papm? In particular,
    -- what are these CLOSURE_MAX_ARGS thing?
    panicM "// ERR: emitApp : ys.size > closureMaxArgs"
    emitLhs z; emit (escape "lz.papExtend");
    emit "("; emitArgs ys; emit ")";
    emit ": (";  emitArgsOnlyTys ys tys; emit ") -> !lz.value"
    emitLn "\n";
  else do
    emitLhs z; emit (escape ("lz.papExtend")); 
    emit "("; emit "%"; emit f; emit ", "; emitArgs ys; emit ")";
    emit " : ("; emit "!lz.value ,"; emitArgsOnlyTys ys tys; emit ")";
    emit " -> ";
    emit "("; emitVarTy z tys; emit ")"; 
    emitLn "";

-- | I added a lean_box_uint8
def emitBoxFn (xType : IRType) : M Unit :=
  match xType with
  | IRType.usize  => emit "call @lean_box_usize"
  | IRType.uint8  => emit "call @lean_box_uint8"
  | IRType.uint32 => emit "call @lean_box_uint32"
  | IRType.uint64 => emit "call @lean_box_uint64"
  | IRType.float  => emit "call @lean_box_float"
  | other         => emit "call @lean_box_OTHER"

def emitBox (z : VarId) (x : VarId) (xType : IRType) : M Unit := do
  emitLhs z; emitBoxFn xType; emit "(%"; emit x; emit ") : ";
  emit "("; emit (toCType xType);
  -- emit "i32";
  emit ") -> (!lz.value)";
   emit $ " // ERR: xType: " ++ (toString xType);
  emit "\n"

-- | I added a lean_unbox_uint8
def emitUnbox (z : VarId) (t : IRType) (x : VarId) : M Unit := do
  emitLhs z;
  match t with
  | IRType.usize  => emit "call @lean_unbox_usize"
  | IRType.uint8  => emit "call @lean_unbox_uint8"
  | IRType.uint32 => emit "call @lean_unbox_uint32"
  | IRType.uint64 => emit "call @lean_unbox_uint64"
  | IRType.float  => emit "call @lean_unbox_float"
  | other         => emit $ "call @lean_unbox_OTHER"
  emit "(%"; emit x; emit ") : ";
  emit "(!lz.value)"; emit " -> ("; emit (toCType t); emit ")";
  emit $ "\n//^UNBOX type: (" ++ toCType t ++")";
  emit "\n"
  

-- | when writing into a variable sign-extend boolean i1s into i8s.
-- This is SUCH a clusterfuck.
def emitIsShared (z : VarId) (x : VarId) : M Unit := do
  let excl <- gensym "exclusive";
  emit $ "%" ++ excl ++ " = call @lean_is_exclusive(%" ++ (toString x) ++ ")";
  emitLn $ " : (!lz.value) -> i1";
  emitLhs z; emit $ (escape "ptr.not") ++ "(%" ++ excl ++ ")";
  emitLn $ " : (i1) -> i8"

def emitIsTaggedPtr (z : VarId) (x : VarId) : M Unit := do
  let scalar <- gensym "scalar";
  emit $ "%" ++ scalar ++ " = call @lean_is_scalar(%" ++ (toString x) ++ ")";
  emitLn $ " : (!lz.value) -> i1";
  emitLhs z; emit $  (escape "ptr.not") ++ "(%" ++ scalar ++ ")";
  emitLn $ " : (i8) -> i8"


def toHexDigit (c : Nat) : String :=
  String.singleton c.digitChar

def quoteString (s : String) : String :=
  let q := "\"";
  let q := s.foldl
    (fun q c => q ++
      if c == '\n' then "\\n"
      else if c == '\n' then "\\t"
      else if c == '\\' then "\\\\"
      else if c == '\"' then "\\\""
      -- commented by bollu
      -- else if c.toNat <= 31 then
      --  "\\x" ++ toHexDigit (c.toNat / 16) ++ toHexDigit (c.toNat % 16)
      -- TODO(Leo): we should use `\unnnn` for escaping unicode characters.
      else String.singleton c)
    q;
  q ++ "\""

def emitNumLit (t : IRType) (v : Nat) : M Unit := do
  if t.isObj then
    if v < UInt32.size then do
      emit (escape "lz.int");
      emit "(){value="; emit v; emit "}"; 
      emit ": () ->"; emit "(";  emit (toCType t); emit ")"; emit "\n";
      -- emit "lean_unsigned_to_nat("; emit v; emit "u)"
    else
     -- panicM "// ERR: lean_cstr_to_nat"
    emit (escape "lz.largeint");
    emit "(){value="; emit (escape v); emit "}"; 
    emitLn $ ": () -> (!lz.value)"   
  else
    emit "std.constant "; emit v; emit " : "; emitLn (toCType t);


def emitLit (z : VarId) (t : IRType) (v : LitVal) : M Unit := do
  emitLhs z;
  match v with
  | LitVal.num v => emitNumLit t v
  | LitVal.str v => 
     emit (escape "lz.string"); emit "()"; emit "{value="; emit (quoteString v); emit "}";
     emit ": () -> "; emit "("; emit (toCType t); emit ")";
     emitLn "";

-- | emit expression / Expr
def emitVDecl (z : VarId) (t : IRType) (v : Expr)  (tys: HashMap VarId IRType) : M Unit :=
  match v with
  | Expr.ctor c ys      => emitExprCtor z c ys tys
  | Expr.reset n x      => do 
    emitLn "// ERR: Expr.reset"
    emitReset z n x tys
  | Expr.reuse x c u ys => do
     emitLn "// ERR: Expr.reuse"
     emitReuse z x c u ys tys
  | Expr.proj i x       => do
      emitLn "// ERR: Expr.proj"
      emitProj z i x tys
  | Expr.uproj i x      => panicM "// ERR: Expr.uproj" -- emitUProj z i x
  | Expr.sproj n o x    => do
     emitLn "// ERR: Expr.sproj";
     emitSProj z t n o x tys
  | Expr.fap c ys       => do
    emitLn "// ERR: Expr.fap";
    emitLhs z; 
    emitFullApp c ys tys IsTail.no
  | Expr.pap c ys       =>  do
      emitLn "// ERR: Expr.pap"
      emitPartialApp z c ys tys
  | Expr.ap x ys        =>  do
     emitLn "// Err: Expr.ap"; 
     emitApp z x ys tys
  | Expr.box t x        => do
    emitLn "// ERR: Expr.box"
    emitBox z x t
  |
   Expr.unbox x        => do
    emitLn "// ERR: Expr.unbox"
    emitUnbox z t x
  | Expr.isShared x     => do 
     emitLn  "// ERR: Expr.isShared"
     emitIsShared z x
  | Expr.isTaggedPtr x  => do
    emitLn "// ERR: Expr.isTaggedPtr: "
    emitIsTaggedPtr z x
  | Expr.lit v          => do emitLn "//ERR: Expr.lit"; emitLit z t v

def isTailCall (x : VarId) (v : Expr) (b : FnBody) : M Bool := do
  let ctx ← read;
  match v, b with
  | Expr.fap f _, FnBody.ret (Arg.var y) => pure $ f == ctx.mainFn && x == y
  | _, _ => pure false

def paramEqArg (p : Param) (x : Arg) : Bool :=
  match x with
  | Arg.var x => p.x == x
  | _ => false

/-
Given `[p_0, ..., p_{n-1}]`, `[y_0, ..., y_{n-1}]`, representing the assignments
```
p_0 := y_0,
...
p_{n-1} := y_{n-1}
```
Return true iff we have `(i, j)` where `j > i`, and `y_j == p_i`.
That is, we have
```
      p_i := y_i,
      ...
      p_j := p_i, -- p_i was overwritten above
```
-/
def overwriteParam (ps : Array Param) (ys : Array Arg) : Bool :=
  let n := ps.size;
  n.any $ fun i =>
    let p := ps[i]
    (i+1, n).anyI fun j => paramEqArg p ys[j]

-- | Heavily modified. Just does a regular call.
-- | TODO: add an attribute to my call instruction that tracks that 
-- this must translate into a @llvm.musttail. This ensure that
-- tail call semantics are preserved, while possibly allowing for better
-- codegen/LLVM shenanigans.
def emitTailCall (v : Expr) (tys: HashMap VarId IRType): M Unit :=
  match v with
  | Expr.fap f ys => do
     let decl ← getDecl f
     -- | good old war3 JASS memories...
     let ret <- gensym "retTailCall"
     emit ("%" ++ ret ++ " = ");
     emitFullApp f ys tys IsTail.yes
     emit $ (escape "lz.return")  ++ "(%" ++ ret ++  ")";
     emit " : ("; emit (toCType decl.resultType); emit ") -> ()"
     emitLn ""
  | _ => throw "bug at emitTailCall"

mutual

-- partial def emitIf (x : VarId) (xType : IRType) (tag : Nat) (t : FnBody) (e : FnBody) : M Unit := do
--   emit "eif ("; emitTag x xType; emit " == "; emit tag; emitLn ")";
--   emitFnBody t {} EmitIrrelevant.no;
--   emitLn "else";
--   emitFnBody e {} EmitIrrelevant.no;


-- I have no idea why writing `do` notation gives me weird
-- universe errors. I believe that in LEAN, it is illegal to leave a
-- monadic value "unconsumed". So if `f, g :: m a`:
-- it is illegal to write [do f; g]
-- One MUST write [do let _ <- f; let _ <- g]
-- TODO: upstream this.
partial def forMIx_ [Monad m] 
  (f : Nat → α → m Unit) (as : Array α)  (start := 0) (stop := as.size): m Unit := do
  as.foldlM (init := 0) (start := start) (stop := stop) 
    (fun i v => do let _ <- (f i v); pure (i+1)) *> pure ()



partial def emitCaseObj (x : VarId) (xType : IRType) (alts : Array Alt) 
        (tys: HashMap VarId IRType): M Unit := do
 let alts := ensureHasDefault alts;
 emit (escape ("lz.caseRet")); emit "("; emit "%"; emit x; emit ")";
 emit "("; 
 forMIx_ (as:= alts) (fun ix alt => do
    emit (if ix > 0 then ", " else "");
    match alt with 
     |  Alt.ctor info b => emitLn "{"; emitFnBody b tys EmitIrrelevant.no; emitLn "}"
     |  Alt.default b => emitLn "{"; emitFnBody b tys EmitIrrelevant.no; emitLn "}")
 emit ")";
 emit "{";
  forMIx_ (as:= alts) (fun ix alt => do
    emit (if ix > 0 then ", " else "");
    match alt with 
     |  Alt.ctor info b => emit $ "alt" ++ (toString ix) ++ "=" ++ toString (info.cidx);
     |  Alt.default b => emit $ "alt" ++ (toString ix) ++ "=" ++ "@default";
    );
 emit "}";
 emitLn "";
 -- TODO: emit case LHSs
 -- TODO: emit return type of case. How?
 emit " : ";
 emit "("; emit (toCType xType); emit ")"; emit " -> "; emit "()";
 emitLn "";

-- | when does this EVER emit a default? As far as I can tell, integer pattern matches
-- are emitted as 
--   caseInt lean_dec_eq(x, LHS) { 0 -> ...; 1 -> ... }
-- so there is no way to even GET a @default.
-- | The problem now is that when we emit a caseInt,
-- the scrutinee seems to ALWAYS be a boolean (i1) that comes from some
-- other check, NOT an i8. So I'm going to be changing the code
-- that is generated by caseInt to directly generate the scf.if.
partial def emitCaseInt (x : VarId) (xType : IRType) (alts : Array Alt) 
        (tys: HashMap VarId IRType): M Unit := do
 let alts := ensureHasDefault alts;
 emit (escape ("lz.caseIntRet")); emit "("; emit "%"; emit x; emit ")";
 emit "("; 
 forMIx_ (as:= alts) (fun ix alt => do
    emit (if ix > 0 then ", " else "");
    match alt with 
     |  Alt.ctor info b => emitLn "{"; emitFnBody b tys EmitIrrelevant.no; emitLn "}";
     |  Alt.default b => emitLn "{"; emitFnBody b tys EmitIrrelevant.no; emitLn "}";)
 emit ")";
 emitLn "";
 emit "{";
 forMIx_ (as:= alts) (fun ix alt => do
     emit (if ix > 0 then ", " else "");
     emit $ "alt" ++ (toString ix) ++ "=";
     match alt with
      | Alt.ctor info b => emit info.cidx
      | Alt.default b => emit "@default"; 
 )
 emit "}";
 emit " : ";
 emit "("; emit (toCType xType); emit ")"; emit " -> "; emit "()";
 emitLn "";
 

 
 

partial def emitCase (x : VarId) (xType : IRType) (alts : Array Alt) 
        (tys: HashMap VarId IRType): M Unit :=
    if xType.isObj
  then emitCaseObj x xType alts tys
  else emitCaseInt x xType alts tys -- this is encoded as an if-then-else.

 
                      
 -- emitLn $ (escape "lz.caseRet") ++ "(%" ++ format x ++ ")" ++
 -- "("  ++ formatArray (Array.map (formatAltRHS loop indent) cs) ++ ")" 
 -- ++ "{" ++ formatArray (Array.map (formatAltLHS (cs.size) indent) cs)  ++ "}" 
 -- ++ ":" ++ formatMLIRType 1 0
                                   

  -- match isIf alts with
  -- | some (tag, t, e) => emitIf x xType tag t e
  -- | _ => do
  --   emit "switch ("; emitTag x xType; emitLn ") {";
  --   let alts := ensureHasDefault alts;
  --   alts.forM fun alt => do
  --     match alt with
  --     | Alt.ctor c b  => emit "case "; emit c.cidx; emitLn ":"; (emitFnBody b {})
  --     | Alt.default b => emitLn "default: "; (emitFnBody b {})
  --   emitLn "}"

-- | This emits a join point as a lz.joinpoint region
partial def emitJoinPointDecl (j : JoinPointId) (xs : Array Param) (inblock : FnBody)
  (rest : FnBody) (tys: HashMap VarId IRType) : M Unit := do
    emit ((escape "lz.joinpoint") ++ "()");
    emit "({\n";
    emit "^entry(";  
    xs.size.forM fun i => do
      if i > 0 then emit ", "
      let x := xs[i]
      emit "%"; emit x.x; emit ": "; emit (toCType x.ty)
    emit "):\n";
    let tysInBlock := xs.foldl (fun hashmap p => (hashmap.insert p.x p.ty)) tys
    emitBlock inblock tysInBlock;
    emit "}, {\n";
    emitBlock rest tys;
    emit "})";
    emit $ " { value= " ++ (toString j.idx) ++ "}";
    emitLn ": () -> ()";

-- | this emits a join point as a BB 
-- partial def emitJoinPointDecl (j : JoinPointId) (xs : Array Param) (inblock : FnBody)
--   (rest : FnBody) (tys: HashMap VarId IRType) : M Unit := do
--     emitBlock rest tys;
--     emit "^jp"; emit (toString j.idx); emit "(";  
--     xs.size.forM fun i => do
--       if i > 0 then emit ", "
--       let x := xs[i]
--       emit "%";
--       emit x.x;
--       emit ": ";
--       emit (toCType x.ty);
--     emit "):\n";
--     let tysInBlock := xs.foldl (fun hashmap p => (hashmap.insert p.x p.ty)) tys
--     emitBlock inblock tysInBlock

partial def emitBlock (b : FnBody) (tys: HashMap VarId IRType) : M Unit := do
  match b with
  -- TODO: join point
  | FnBody.jdecl j xs v b      => 
     emitLn "// ERR: fnBody.jdecl"
     emitJoinPointDecl j xs v b tys
  -- TODO: variable declaration
  | d@(FnBody.vdecl x t v b)   =>
    let tys  := tys.insert x t
    let ctx ← read
    if isTailCallTo ctx.mainFn d then
      emitLn "// ERR: fnBody.vdecl (tail call)";
      emitTailCall v tys
    else
      emitLn "//ERR: fnBody.vdecl (non-tail) call";
      emitVDecl x t v (tys.insert x t)
      emitBlock b (tys.insert x t)
  | FnBody.inc x n c p b       =>
    emitLn "// ERR: FnBody.inc "
    -- | p = persistent
    unless p do emitInc x n c
    emitBlock b tys
  | FnBody.dec x n c p b       =>
    emitLn "// ERR: FnBody.dec "
    -- | p = persistent
    unless p do emitDec x n c
    emitBlock  b tys
  | FnBody.del x b             => 
    emitLn "// ERR: FnBody.del";
    emitDel x; emitBlock b tys
  | FnBody.setTag x i b        => 
    emitLn "// ERR: FnBody.setTag";
    emitSetTag x i;
    emitBlock b tys
  | FnBody.set x i y b         =>
    emitLn "// ERR: FnBody.set";
    emitSet x i y; emitBlock b tys
  | FnBody.uset x i y b        =>
    emitLn "// ERR: FnBody.uset";
    emitUSet x i y; emitBlock b tys
  | FnBody.sset x i o y t b    => do
    emitLn "// ERR: FnBody.sset";
    emitSSet x i o y t tys;
    emitBlock b tys
  | FnBody.mdata _ b           => emitBlock b tys
  | FnBody.ret x               =>
    emitLn "//ERR: FnBody.ret"
   -- emit "return "; emitArg x;
   -- TODO: switch to generic form of operation
    emit "lz.return "; emitArg x;
    emit " : ";  emitLn (toCType (lookupArgTy tys x));
  | FnBody.case _ x xType alts => do
    emitLn "// ERR: FnBody.case"
    emitCase x xType alts tys
  | FnBody.jmp j xs            => do
      emitLn "// ERR: FnBody.jmp"
      emitJmp j xs tys
  | FnBody.unreachable         => 
    emitLn "// ERR: FnBody.unreachable" 
    emitLn $ (escape "ptr.unreachable") ++ "() : () -> ()"

-- TODO: this should have access to declarations
partial def emitJPs : FnBody → M Unit
  | FnBody.jdecl j xs v b => do emit j; emitLn ":"; 
                                emitLn "{"; emitFnBody v {} EmitIrrelevant.yes; emitLn "}"
                                emitJPs b
  | e                     => do unless e.isTerminal do emitJPs e.body


-- | function to create a hash map of arguments introduced by this fnBody
partial def insertFnBodyArgTypes (tys: HashMap VarId IRType): 
  FnBody → M (HashMap VarId IRType)
  | e@(FnBody.vdecl x t _ b), d => do
    -- TODO: I might not be doing this right, here! May have to follow
    -- the tail call?
    -- let ctx ← read
    -- if isTailCallTo ctx.mainFn e then
    --   pure d
    -- else
    -- declareVar x t; declareVars b true
    tys
  | FnBody.jdecl j xs _ b, d => do
    -- pure {}
    pure (xs.foldl (fun m p => (m.insert p.x p.ty)) tys)
    -- declareParams xs; declareVars b (d || xs.size > 0)
  | e, d => pure tys




-- EmitIrrelevant is used to emit a value %irrelevant = ptr.undef 
-- at some regions, where we want to create a %irrelevant value that should be
-- in scope to emit an irrelevant argument. 
-- don't emit '{' and '}' because some callees [eg. the calle |emitDeclAux|] generate
-- a preamble. There could be callees who wish to generate postambles.
partial def emitFnBody (b : FnBody) (tys: HashMap VarId IRType)
   (irr: EmitIrrelevant): M Unit := do
  -- emitLn "{"
  match irr with
     | EmitIrrelevant.yes => 
        emitLn $ "%c0_irr = std.constant 0 : i32"
        emitLn $ "%irrelevant = call @lean_box(%c0_irr) : (i32) -> (!lz.value)"
     | EmitIrrelevant.no => pure ()
  let tys <- insertFnBodyArgTypes tys b
  emitBlock b tys
  -- emitLn "}"

end
  
-- called from emitFns -> emitDecl -> emitDeclAux
def emitDeclAux (d : Decl) : M Unit := do
  let dname <- toCName d.name
  emitLn ("// ERR: emitDeclAux ("  ++ dname ++ ") | isExtern?" ++ (format (Decl.isExtern d)))
  let env ← getEnv
  let (vMap, jpMap) := mkVarJPMaps d
  withReader (fun ctx => { ctx with jpMap := jpMap }) do
  -- | TODO: what does hasInitAttr guard against?
  -- unless (hasInitAttr env d.name) do
  do
    match d with
    | Decl.fdecl (f := f) (xs := xs) (type := t) (body := b) .. => do
      emitLn ("// ERR: emitDeclAux Decl.fdecl ("  ++ dname ++ ")")
      let baseName ← toCName f;
      -- if xs.size == 0 then -- TODO: what is this doing?
      --   emit "static " -- TODO: understand what this is doing
      emit "func ";
      -- emit (toCType t); emit " ";
      if xs.size > 0 then
        emit ("@" ++ (escape baseName));
        emit "(";
        if xs.size > closureMaxArgs && isBoxedName d.name then
         emit "%_args : !ptr.array" -- not sure if this is the right translation!
          -- emit "lean_object** _args"
        else
          xs.size.forM fun i => do
            if i > 0 then emit ", "
            let x := xs[i]
            emit "%"; emit x.x; emit ": "; emit (toCType x.ty)
        emit ")"
        emit $ " -> " ++ (toCType t)
      else -- [xs.size == 0]
        -- TODO: there is something super funky about this codegen here!
        -- In particular, I don't understand this __init__ invariant.
        emitLn ("@_init_" ++ baseName ++ "()" ++ " -> " ++ (toCType t))
      
      emitLn "{"; -- open fn body
      -- | Do not have args like this.
      if xs.size > closureMaxArgs && isBoxedName d.name then
         xs.size.forM fun i => do
           let x := xs[i]
           -- emit "lean_object* "; emit x.x; emit " = _args["; emit i; emitLn "];"
           let ix <- emitI32 "ix" i
           emit $ "%" ++ toString x.x ++ " = ";
           emit $ (escape "ptr.loadarray") ++  "(%_args, %" ++ ix ++ ") : ";
           emitLn $ "(!ptr.array, i32) -> !lz.value"      
      withReader (fun ctx => { ctx with mainFn := f, mainParams := xs })
                 (emitFnBody b 
                             ((xs.foldl (fun m x => (m.insert x.x x.ty)) {}))
                             EmitIrrelevant.yes);
      emitLn "}";

    | _ => emitLn "// ERR: unknwown decl"; pure ()

-- calle from emitFns
def emitDecl (d : Decl) : M Unit := do
  let d := d.normalizeIds; -- ensure we don't have gaps in the variable indices
  try
    emitDeclAux d
  catch err =>
    throw s!"{err}\ncompiling:\n{d}"
    panic s!"{err}\ncompiling:\n{d}"

def emitFns : M Unit := do
  let env ← getEnv;
  let decls := getDecls env;
  decls.reverse.forM emitDecl

-- def emitMarkPersistent (d : Decl) (n : Name) : M Unit := do
def emitMarkPersistent (d : Decl) (valueName : String) : M Unit := do
  if d.resultType.isObj then
    -- emit "lean_mark_persistent("; emitCName n; emitLn ");"
    emit "call @lean_mark_persistent(%"; emit valueName; emitLn ") : (!lz.value) -> ()"



def emitDeclInit (d : Decl) : M Unit := do
  let env ← getEnv
  let n := d.name
  emitLn $ "// ERR: emitDeclInit: (" ++ n ++ ")"
  if isIOUnitInitFn env n then
     let resIOName <- gensym "result"
     let worldName <- gensym "world"
    -- emit "res = "; emitCName n; emitLn "(lean_io_mk_world());"
     emitLn $ "%" ++ worldName ++ " = call @lean_io_mk_world() : () -> !lz.value"
     emit ("%" ++ resIOName ++ " = " ++ "call @"); emitCName n; emit $ "(%" ++ worldName ++ ")";
     emit " : (!lz.value) -> "; emit (toCType ∘ Decl.resultType $ d); emitLn "";
    -- emitLn "if (lean_io_result_is_error(res)) return res;"
    -- emitLn "lean_dec_ref(res);"
  else if d.params.size == 0 then
    match getInitFnNameFor? env d.name with
    | some initFn =>
          -- emit "res = "; emitCName initFn; emitLn "(lean_io_mk_world());"
          let resIOName <- gensym "result"
          let worldName <- gensym "world"
          emitLn $ "%" ++ worldName ++ " = " ++ "call @lean_io_mk_world() : () -> !lz.value"
          emit ("%" ++ resIOName ++ " = " ++ "call @"); emitCName initFn; 
          emit $ "(%" ++ worldName ++ ")";
          emit " : (!lz.value) -> "; emit (toCType ∘ Decl.resultType $ d); emitLn "";
          -- emitLn "if (lean_io_result_is_error(res)) return res;"
          -- emitCName n; emitLn " = lean_io_result_get_value(res);"
          let resValueName <- gensym "resultVal"
          emitLn $ "%" ++ resValueName ++ " = " ++ "std.call @lean_io_result_get_value(%" ++ resIOName ++") : (!lz.value) -> !lz.value"
          emit $ (escape "ptr.storeglobal"); 
          emit "(%";  emit resValueName; emit ")";
          emit "{value=@"; emitCName n; emit "}"
          emit ": ("; emit (toCType ∘ Decl.resultType $ d); emit ") -> ()"; emitLn "";
          -- emitMarkPersistent d n
          emitMarkPersistent d resValueName
          -- emitLn "lean_dec_ref(res);"
     | _ =>
          -- emitCName n; emit " = "; emitCInitName n; emitLn "();"; emitMarkPersistent d n
         let resName <- gensym "result";
         emit ("%" ++ resName ++ " = " ++ "call @"); emitCInitName n; emit "()";
         emit ": () -> "; emit (toCType ∘ Decl.resultType $ d); emitLn "";
         emit $ (escape "ptr.storeglobal"); emit "(%";  emit resName ; emit ")";
         emit "{value=@"; emitCName n; emit "}";
         emit " : ("; emit (toCType ∘ Decl.resultType $ d); emit  ") -> ()"; emitLn "";
         -- emitMarkPersistent d n
         emitMarkPersistent d resName

def emitInitFn : M Unit := do
  let env ← getEnv
  let modName ← getModName
  -- assertM "expected only one import" (env.imports.toList.length == 1)
    -- | TODO: figure out what this code is doing. As it is currently written,
  -- the C code makes no sense to me. It calls the initialization function on itself???
  -- I guess the difference is between modName and imp.module; I don't understand
  -- the difference.
  -- this FORWARD DECLARES the initialization for modules.
  env.imports.forM fun imp => do
    emitLn $ "func private @" ++ mkModuleInitializationFunctionName imp.module ++ 
       "(!lz.value) -> (!lz.value)"

  -- | emit our shim entrypoint that also initializes LEAN
  emitLn$ "func private @" ++ "init_lean_custom_entrypoint_hack(%in :!lz.value) -> !lz.value {";
  let usesLeanAPI := usesModuleFrom env `Lean
  if usesLeanAPI then
    emitLn "call @lean_initialize() : () -> ()"
  emitLn $ "  %out = call @" ++ mkModuleInitializationFunctionName modName ++ "(%in) : (!lz.value) -> (!lz.value)" 
  emitLn $ "  return %out: !lz.value"
  emitLn $ "}"

  -- | global variable holding initialization status
  emit $ "\"ptr.global\"(){value=@_G_initialized, type=i1} : () -> ()"
  -- | emit internal module entrypoint which is to load plugins
  emitLn $ "func private @" ++ mkModuleInitializationFunctionName modName  ++ "(%in: !lz.value) -> (!lz.value) {"
  -- | if (! _G_initialized) {
  emitLn $ "%inited = \"ptr.loadglobal\"(){value=@\"_G_initialized\"} : () -> i1";
  emitLn $ "%falseval = std.constant 0 : i1"
  emitLn $ "%notinited = std.cmpi eq, %inited, %falseval : i1"
  emitLn $ " scf.if %notinited {"
  let worldname <- gensym "world"
  emitLn $ "%" ++ worldname ++ " = call @lean_io_mk_world() : () -> (!lz.value)"
   
  env.imports.forM fun imp => do
     -- emitLn $ " //ERR: initialization: (" ++ mkModuleInitializationFunctionName modName ++ ")"
     -- emit $ "func private @" ++ mkModuleInitializationFunctionName modName;
     -- | name of lean entrypoint
     -- | this CALLS the initialization function for MODULES
     emitLn $ "//ERR: initializing imp.module(" ++ 
         (mkModuleInitializationFunctionName imp.module) ++ ")"
     let initResult <- gensym "initResult"
     emitLn ("%" ++ initResult  ++ " = " ++
       "call @" ++ mkModuleInitializationFunctionName imp.module ++ 
       "(" ++  "%" ++ worldname ++ ")" ++ 
       " : (!lz.value) -> !lz.value"
       )
     -- emitLn $ (escape "ptr.storeglobal") ++  "(){value=@" ++ 
     emitLn $ "call @lean_dec_ref(%" ++ initResult ++ ") : (!lz.value) -> ()"
    -- | done initing everyone -- |  
  -- | this CALLS the different DECLARATIONS in the file.
  let decls := getDecls env
  decls.reverse.forM emitDeclInit
    -- emitLns ["return lean_io_result_mk_ok(lean_box(0));", "}"]
  emitLn "}" -- close scf.if of testing whether we are re-running initialization.
  emitLn "%c0 = constant 0 : i32"
  emitLn "%box0 = call @lean_box(%c0) : (i32) -> !lz.value"
  emitLn "%out = call @lean_io_result_mk_ok(%box0) : (!lz.value) -> !lz.value"
  emitLn "return %out : !lz.value"
  emitLn "}"
 

def main : M Unit := do
  -- emitFileHeader
  emitPreamble
  emitFnFwdDecls
  emitFns
  emitInitFn
  -- emitMainFnIfNeeded
  -- emitFileFooter

end EmitMLIR

@[export lean_ir_emit_mlir]
def emitMLIR (env : Environment) (modName : Name) : Except String String :=
  let initState := { out := "", guid := 0  : EmitMLIR.State };
  match (EmitMLIR.main { env := env, modName := modName }).run initState with
  | EStateM.Result.ok    _   s => Except.ok s.out
  | EStateM.Result.error err _ => Except.error err

end Lean.IR
