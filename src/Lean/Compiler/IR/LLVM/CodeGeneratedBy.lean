/-
Copyright (c) 2023 Siddharth Bhat. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Siddharth Bhat
-/
import Lean
import Lean.Compiler.LLVM.Pure

namespace Lean.Compiler.LLVM.CodeGeneratedBy
open Lean

def LLVMCodeGenerator : Type := List Reg → BuilderM Reg

#check PersistentEnvExtension
builtin_initialize codeGeneratedByExt : PersistentEnvExtension Name (Name × LLVMCodeGenerator) (List Name × LLVMCodeGenerator) ←
  registerPersistentEnvExtension {
    mkInitial := return ([], builtinPassManager)
    addImportedFn := fun ns => return ([], ← ImportM.runCoreM <| runImportedDecls ns)
    addEntryFn := fun (installerDeclNames, _) (installerDeclName, managerNew) => (installerDeclName :: installerDeclNames, managerNew)
    exportEntriesFn := fun s => s.1.reverse.toArray
  }

def getPassManager : CoreM PassManager :=
  return passManagerExt.getState (← getEnv) |>.2

def addPass (declName : Name) : CoreM Unit := do
  let info ← getConstInfo declName
  match info.type with
  | .const `Lean.Compiler.LCNF.PassInstaller .. =>
    let managerNew ← runFromDecl (← getPassManager) declName
    modifyEnv fun env => passManagerExt.addEntry env (declName, managerNew)
  | _ =>
    throwError "invalid 'cpass' only 'PassInstaller's can be added via the 'cpass' attribute: {info.type}"

builtin_initialize
  registerBuiltinAttribute {
    name  := `codeGeneratedBy
    descr := "functions that are code generated by a custom LLVM builder."
    add   := fun declName stx kind => do
      Attribute.Builtin.ensureNoArgs stx
      unless kind == AttributeKind.global do throwError "invalid attribute codeGeneratedBy, must be global"
      discard <| addPass declName
    applicationTime := .afterCompilation
  }
