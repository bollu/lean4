/-
Copyright (c) 2023 Siddharth Bhat. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Siddharth Bhat
-/
import Lean
import Lean.Environment
import Lean.Attributes
import Lean.Compiler.IR.LLVM.Pure

namespace Lean.IR.LLVM.CodeGeneratedBy
open Lean
open Lean.IR.LLVM.Pure

def CodeGenerator : Type := List Reg → BuilderM Reg

instance : Inhabited CodeGenerator where
  default := fun _ => pure (0 : Reg)

-- Unqualified `getEnv` refers to `CompilerM.getEnv`, which
-- assumes the specific `CompilerM` monad stack, instead of implementing
-- `MonadEnv CompilerM`.
-- Thus, we explicitly refer to `MonadEnv.getEnv`
-- TODO: Refactor `CompilerM` to use `MonadEnv`.

private unsafe def getLLVMCodeGeneratorUnsafe (declName : Name) : CoreM CodeGenerator := do
  ofExcept <| (← MonadEnv.getEnv).evalConstCheck CodeGenerator (← getOptions) ``CodeGenerator declName

/-- Unsafely lookup a declaration, and cast its value into a code generator -/
@[implemented_by getLLVMCodeGeneratorUnsafe]
private opaque lookupCodeGeneratorForDeclaration (declName : Name) : CoreM CodeGenerator

/-- does `PersistentEnvExtension` not know how to use `HashMap` ? -/
-- #check MapDeclarationExtension
builtin_initialize codeGeneratorExt : MapDeclarationExtension CodeGenerator ←
  mkMapDeclarationExtension
/-
     registerPersistentEnvExtension {
       mkInitial := do
         dbg_trace s!"codeGeneratorExt: mkInitial=><="
         return HashMap.empty
       addImportedFn := fun _ => return HashMap.empty
    -- addImportedFn := fun nss => do -- what does this do?
    --   dbg_trace s!"codeGeneratorExt: addImportedFn '{nss}'=>"
    --   let mut out : HashMap Name CodeGenerator := {}
    --   for ns in nss do
    --     for n in ns do
    --       out := out.insert n (← ImportM.runCoreM <| lookupCodeGeneratorForDeclaration n)
    --   dbg_trace s!"<=addImportedFn"
    --   pure out
    addEntryFn := fun state entry =>
      dbg_trace s!"addEntryFn"
      let out := state.insert entry.fst entry.snd
      dbg_trace s!"<=addEntryFn"
      out
    exportEntriesFn := fun state =>
      dbg_trace s!"exportEntriesFn=>"
      let out := state.toArray.map Prod.fst
      dbg_trace s!"<=exportEntriesFn"
      out
  }
-/

/-- get the code generator for a given declaration name -/
def getCodeGeneratorFromEnv? (env : Environment) (name : Name) : Option CodeGenerator :=
   codeGeneratorExt.find? env name

/-- add a code generator, given the declaration name and the code generator -/
def addCodeGenerator (declName : Name) (gen : CodeGenerator) : CoreM Unit := do
    MonadEnv.modifyEnv fun env => codeGeneratorExt.insert env declName gen

/-- add a code generator, given the declaration name -/
def addCodeGeneratorFromDeclName (declName : Name) : CoreM Unit := do
  let info ← getConstInfo declName
  match info.type with
  | .const ``Lean.IR.LLVM.CodeGeneratedBy.CodeGenerator .. =>
    addCodeGenerator declName (← lookupCodeGeneratorForDeclaration declName)
  | _ =>
    throwError "Expected type 'CodeGenerator', found incorrect type '{info.type}'. Invalid code generator declaration '{declName}'."

builtin_initialize
  registerBuiltinAttribute {
    name  := `codeGeneratedBy
    descr := "functions that are code generated by a custom LLVM builder."
    applicationTime := .afterCompilation
    add   := fun declName stx kind => do
      Attribute.Builtin.ensureNoArgs stx
      -- | TODO: what does a global attribute kind mean?
      unless kind == AttributeKind.global do throwError "invalid attribute 'codeGeneratedBy', must be global"
      addCodeGeneratorFromDeclName declName
  }
end Lean.IR.LLVM.CodeGeneratedBy
