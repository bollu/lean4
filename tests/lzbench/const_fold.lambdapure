
[init]
def Expr.mkExpr.match_1._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) : obj :=
  let x_5 : obj := 0;
  let x_6 : u8 := Nat.decEq x_1 x_5;
  case x_6 : obj of
  Bool.false →
    let x_7 : obj := 1;
    let x_8 : obj := Nat.sub x_1 x_7;
    let x_9 : obj := app x_4 x_8 x_2;
    ret x_9
  Bool.true →
    let x_10 : obj := app x_3 x_2;
    ret x_10
def Expr.mkExpr.match_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap Expr.mkExpr.match_1._rarg;
  ret x_2
[init]
def Expr.mkExpr._closed_1 : obj :=
  let x_1 : obj := 1;
  let x_2 : obj := ctor_0[Expr.Var] x_1;
  ret x_2
def Expr.mkExpr (x_1 : obj) (x_2 : obj) : obj :=
  let x_3 : obj := 0;
  let x_4 : u8 := Nat.decEq x_1 x_3;
  case x_4 : obj of
  Bool.false →
    let x_5 : obj := 1;
    let x_6 : obj := Nat.sub x_1 x_5;
    let x_7 : obj := Nat.add x_2 x_5;
    let x_8 : obj := Expr.mkExpr x_6 x_7;
    let x_9 : obj := Nat.sub x_2 x_5;
    let x_10 : obj := Expr.mkExpr x_6 x_9;
    let x_11 : obj := ctor_2[Expr.Add] x_8 x_10;
    ret x_11
  Bool.true →
    let x_12 : u8 := Nat.decEq x_2 x_3;
    case x_12 : obj of
    Bool.false →
      let x_13 : obj := ctor_1[Expr.Val] x_2;
      ret x_13
    Bool.true →
      let x_14 : obj := Expr.mkExpr._closed_1;
      ret x_14
[init]
def Expr.appendAdd.match_1._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_5 : obj := app x_4 x_1 x_2;
    ret x_5
  Expr.Val →
    let x_6 : obj := app x_4 x_1 x_2;
    ret x_6
  Expr.Add →
    let x_7 : obj := proj[0] x_1;
    let x_8 : obj := proj[1] x_1;
    let x_9 : obj := app x_3 x_7 x_8 x_2;
    ret x_9
  Expr.Mul →
    let x_10 : obj := app x_4 x_1 x_2;
    ret x_10
def Expr.appendAdd.match_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap Expr.appendAdd.match_1._rarg;
  ret x_2
[init]
def Expr.appendAdd (x_1 : obj) (x_2 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_3 : obj := ctor_2[Expr.Add] x_1 x_2;
    ret x_3
  Expr.Val →
    let x_4 : obj := ctor_2[Expr.Add] x_1 x_2;
    ret x_4
  Expr.Add →
    let x_5 : obj := proj[0] x_1;
    let x_6 : obj := proj[1] x_1;
    let x_7 : obj := Expr.appendAdd x_6 x_2;
    let x_8 : obj := ctor_2[Expr.Add] x_5 x_7;
    ret x_8
  Expr.Mul →
    let x_9 : obj := ctor_2[Expr.Add] x_1 x_2;
    ret x_9
[init]
def Expr.appendMul.match_1._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_5 : obj := app x_4 x_1 x_2;
    ret x_5
  Expr.Val →
    let x_6 : obj := app x_4 x_1 x_2;
    ret x_6
  Expr.Add →
    let x_7 : obj := app x_4 x_1 x_2;
    ret x_7
  Expr.Mul →
    let x_8 : obj := proj[0] x_1;
    let x_9 : obj := proj[1] x_1;
    let x_10 : obj := app x_3 x_8 x_9 x_2;
    ret x_10
def Expr.appendMul.match_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap Expr.appendMul.match_1._rarg;
  ret x_2
[init]
def Expr.appendMul (x_1 : obj) (x_2 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_3 : obj := ctor_3[Expr.Mul] x_1 x_2;
    ret x_3
  Expr.Val →
    let x_4 : obj := ctor_3[Expr.Mul] x_1 x_2;
    ret x_4
  Expr.Add →
    let x_5 : obj := ctor_3[Expr.Mul] x_1 x_2;
    ret x_5
  Expr.Mul →
    let x_6 : obj := proj[0] x_1;
    let x_7 : obj := proj[1] x_1;
    let x_8 : obj := Expr.appendMul x_7 x_2;
    let x_9 : obj := ctor_3[Expr.Mul] x_6 x_8;
    ret x_9
[init]
def Expr.reassoc.match_1._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_5 : obj := app x_4 x_1;
    ret x_5
  Expr.Val →
    let x_6 : obj := app x_4 x_1;
    ret x_6
  Expr.Add →
    let x_7 : obj := proj[0] x_1;
    let x_8 : obj := proj[1] x_1;
    let x_9 : obj := app x_2 x_7 x_8;
    ret x_9
  Expr.Mul →
    let x_10 : obj := proj[0] x_1;
    let x_11 : obj := proj[1] x_1;
    let x_12 : obj := app x_3 x_10 x_11;
    ret x_12
def Expr.reassoc.match_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap Expr.reassoc.match_1._rarg;
  ret x_2
[init]
def Expr.reassoc (x_1 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    ret x_1
  Expr.Val →
    ret x_1
  Expr.Add →
    let x_2 : obj := proj[0] x_1;
    let x_3 : obj := proj[1] x_1;
    let x_4 : obj := Expr.reassoc x_2;
    let x_5 : obj := Expr.reassoc x_3;
    let x_6 : obj := Expr.appendAdd x_4 x_5;
    ret x_6
  Expr.Mul →
    let x_7 : obj := proj[0] x_1;
    let x_8 : obj := proj[1] x_1;
    let x_9 : obj := Expr.reassoc x_7;
    let x_10 : obj := Expr.reassoc x_8;
    let x_11 : obj := Expr.appendMul x_9 x_10;
    ret x_11
[init]
def Expr.constFolding.match_1._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_7 : obj := app x_6 x_1 x_2;
    ret x_7
  Expr.Val →
    let x_8 : obj := proj[0] x_1;
    case x_2 : obj of
    Expr.Var →
      let x_9 : obj := app x_6 x_1 x_2;
      ret x_9
    Expr.Val →
      let x_10 : obj := proj[0] x_2;
      let x_11 : obj := app x_3 x_8 x_10;
      ret x_11
    Expr.Add →
      let x_12 : obj := proj[0] x_2;
      let x_13 : obj := proj[1] x_2;
      block_14 (x_24 : obj) :=
        case x_13 : obj of
        Expr.Var →
          let x_25 : obj := app x_6 x_1 x_2;
          ret x_25
        Expr.Val →
          let x_26 : obj := proj[0] x_13;
          let x_27 : obj := app x_4 x_8 x_12 x_26;
          ret x_27
        Expr.Add →
          let x_28 : obj := app x_6 x_1 x_2;
          ret x_28
        Expr.Mul →
          let x_29 : obj := app x_6 x_1 x_2;
          ret x_29;
      case x_12 : obj of
      Expr.Var →
        let x_15 : obj := ctor_0[PUnit.unit];
        jmp block_14 x_15
      Expr.Val →
        let x_16 : obj := proj[0] x_12;
        case x_13 : obj of
        Expr.Var →
          let x_17 : obj := app x_5 x_8 x_16 x_13;
          ret x_17
        Expr.Val →
          let x_18 : obj := proj[0] x_13;
          let x_19 : obj := app x_4 x_8 x_12 x_18;
          ret x_19
        Expr.Add →
          let x_20 : obj := app x_5 x_8 x_16 x_13;
          ret x_20
        Expr.Mul →
          let x_21 : obj := app x_5 x_8 x_16 x_13;
          ret x_21
      Expr.Add →
        let x_22 : obj := ctor_0[PUnit.unit];
        jmp block_14 x_22
      Expr.Mul →
        let x_23 : obj := ctor_0[PUnit.unit];
        jmp block_14 x_23
    Expr.Mul →
      let x_30 : obj := app x_6 x_1 x_2;
      ret x_30
  Expr.Add →
    let x_31 : obj := app x_6 x_1 x_2;
    ret x_31
  Expr.Mul →
    let x_32 : obj := app x_6 x_1 x_2;
    ret x_32
def Expr.constFolding.match_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap Expr.constFolding.match_1._rarg;
  ret x_2
[init]
def Expr.constFolding.match_2._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_7 : obj := app x_6 x_1 x_2;
    ret x_7
  Expr.Val →
    let x_8 : obj := proj[0] x_1;
    case x_2 : obj of
    Expr.Var →
      let x_9 : obj := app x_6 x_1 x_2;
      ret x_9
    Expr.Val →
      let x_10 : obj := proj[0] x_2;
      let x_11 : obj := app x_3 x_8 x_10;
      ret x_11
    Expr.Add →
      let x_12 : obj := app x_6 x_1 x_2;
      ret x_12
    Expr.Mul →
      let x_13 : obj := proj[0] x_2;
      let x_14 : obj := proj[1] x_2;
      block_15 (x_25 : obj) :=
        case x_14 : obj of
        Expr.Var →
          let x_26 : obj := app x_6 x_1 x_2;
          ret x_26
        Expr.Val →
          let x_27 : obj := proj[0] x_14;
          let x_28 : obj := app x_4 x_8 x_13 x_27;
          ret x_28
        Expr.Add →
          let x_29 : obj := app x_6 x_1 x_2;
          ret x_29
        Expr.Mul →
          let x_30 : obj := app x_6 x_1 x_2;
          ret x_30;
      case x_13 : obj of
      Expr.Var →
        let x_16 : obj := ctor_0[PUnit.unit];
        jmp block_15 x_16
      Expr.Val →
        let x_17 : obj := proj[0] x_13;
        case x_14 : obj of
        Expr.Var →
          let x_18 : obj := app x_5 x_8 x_17 x_14;
          ret x_18
        Expr.Val →
          let x_19 : obj := proj[0] x_14;
          let x_20 : obj := app x_4 x_8 x_13 x_19;
          ret x_20
        Expr.Add →
          let x_21 : obj := app x_5 x_8 x_17 x_14;
          ret x_21
        Expr.Mul →
          let x_22 : obj := app x_5 x_8 x_17 x_14;
          ret x_22
      Expr.Add →
        let x_23 : obj := ctor_0[PUnit.unit];
        jmp block_15 x_23
      Expr.Mul →
        let x_24 : obj := ctor_0[PUnit.unit];
        jmp block_15 x_24
  Expr.Add →
    let x_31 : obj := app x_6 x_1 x_2;
    ret x_31
  Expr.Mul →
    let x_32 : obj := app x_6 x_1 x_2;
    ret x_32
def Expr.constFolding.match_2 (x_1 : ◾) : obj :=
  let x_2 : obj := pap Expr.constFolding.match_2._rarg;
  ret x_2
[init]
def Expr.constFolding (x_1 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    ret x_1
  Expr.Val →
    ret x_1
  Expr.Add →
    let x_2 : obj := proj[0] x_1;
    let x_3 : obj := proj[1] x_1;
    let x_4 : obj := Expr.constFolding x_2;
    let x_5 : obj := Expr.constFolding x_3;
    case x_4 : obj of
    Expr.Var →
      let x_6 : obj := ctor_2[Expr.Add] x_4 x_5;
      ret x_6
    Expr.Val →
      let x_7 : obj := proj[0] x_4;
      case x_5 : obj of
      Expr.Var →
        let x_8 : obj := ctor_2[Expr.Add] x_4 x_5;
        ret x_8
      Expr.Val →
        let x_9 : obj := proj[0] x_5;
        let x_10 : obj := Nat.add x_7 x_9;
        let x_11 : obj := ctor_1[Expr.Val] x_10;
        ret x_11
      Expr.Add →
        let x_12 : obj := proj[0] x_5;
        let x_13 : obj := proj[1] x_5;
        block_14 (x_32 : obj) :=
          case x_13 : obj of
          Expr.Var →
            let x_33 : obj := ctor_2[Expr.Add] x_4 x_5;
            ret x_33
          Expr.Val →
            let x_34 : obj := proj[0] x_13;
            let x_35 : obj := Nat.add x_7 x_34;
            let x_36 : obj := ctor_1[Expr.Val] x_35;
            let x_37 : obj := ctor_2[Expr.Add] x_36 x_12;
            ret x_37
          Expr.Add →
            let x_38 : obj := ctor_2[Expr.Add] x_4 x_5;
            ret x_38
          Expr.Mul →
            let x_39 : obj := ctor_2[Expr.Add] x_4 x_5;
            ret x_39;
        case x_12 : obj of
        Expr.Var →
          let x_15 : obj := ctor_0[PUnit.unit];
          jmp block_14 x_15
        Expr.Val →
          let x_16 : obj := proj[0] x_12;
          case x_13 : obj of
          Expr.Var →
            let x_17 : obj := Nat.add x_7 x_16;
            let x_18 : obj := ctor_1[Expr.Val] x_17;
            let x_19 : obj := ctor_2[Expr.Add] x_18 x_13;
            ret x_19
          Expr.Val →
            let x_20 : obj := proj[0] x_13;
            let x_21 : obj := Nat.add x_7 x_20;
            let x_22 : obj := ctor_1[Expr.Val] x_21;
            let x_23 : obj := ctor_2[Expr.Add] x_22 x_12;
            ret x_23
          Expr.Add →
            let x_24 : obj := Nat.add x_7 x_16;
            let x_25 : obj := ctor_1[Expr.Val] x_24;
            let x_26 : obj := ctor_2[Expr.Add] x_25 x_13;
            ret x_26
          Expr.Mul →
            let x_27 : obj := Nat.add x_7 x_16;
            let x_28 : obj := ctor_1[Expr.Val] x_27;
            let x_29 : obj := ctor_2[Expr.Add] x_28 x_13;
            ret x_29
        Expr.Add →
          let x_30 : obj := ctor_0[PUnit.unit];
          jmp block_14 x_30
        Expr.Mul →
          let x_31 : obj := ctor_0[PUnit.unit];
          jmp block_14 x_31
      Expr.Mul →
        let x_40 : obj := ctor_2[Expr.Add] x_4 x_5;
        ret x_40
    Expr.Add →
      let x_41 : obj := ctor_2[Expr.Add] x_4 x_5;
      ret x_41
    Expr.Mul →
      let x_42 : obj := ctor_2[Expr.Add] x_4 x_5;
      ret x_42
  Expr.Mul →
    let x_43 : obj := proj[0] x_1;
    let x_44 : obj := proj[1] x_1;
    let x_45 : obj := Expr.constFolding x_43;
    let x_46 : obj := Expr.constFolding x_44;
    case x_45 : obj of
    Expr.Var →
      let x_47 : obj := ctor_3[Expr.Mul] x_45 x_46;
      ret x_47
    Expr.Val →
      let x_48 : obj := proj[0] x_45;
      case x_46 : obj of
      Expr.Var →
        let x_49 : obj := ctor_3[Expr.Mul] x_45 x_46;
        ret x_49
      Expr.Val →
        let x_50 : obj := proj[0] x_46;
        let x_51 : obj := Nat.mul x_48 x_50;
        let x_52 : obj := ctor_1[Expr.Val] x_51;
        ret x_52
      Expr.Add →
        let x_53 : obj := ctor_3[Expr.Mul] x_45 x_46;
        ret x_53
      Expr.Mul →
        let x_54 : obj := proj[0] x_46;
        let x_55 : obj := proj[1] x_46;
        block_56 (x_74 : obj) :=
          case x_55 : obj of
          Expr.Var →
            let x_75 : obj := ctor_3[Expr.Mul] x_45 x_46;
            ret x_75
          Expr.Val →
            let x_76 : obj := proj[0] x_55;
            let x_77 : obj := Nat.mul x_48 x_76;
            let x_78 : obj := ctor_1[Expr.Val] x_77;
            let x_79 : obj := ctor_3[Expr.Mul] x_78 x_54;
            ret x_79
          Expr.Add →
            let x_80 : obj := ctor_3[Expr.Mul] x_45 x_46;
            ret x_80
          Expr.Mul →
            let x_81 : obj := ctor_3[Expr.Mul] x_45 x_46;
            ret x_81;
        case x_54 : obj of
        Expr.Var →
          let x_57 : obj := ctor_0[PUnit.unit];
          jmp block_56 x_57
        Expr.Val →
          let x_58 : obj := proj[0] x_54;
          case x_55 : obj of
          Expr.Var →
            let x_59 : obj := Nat.mul x_48 x_58;
            let x_60 : obj := ctor_1[Expr.Val] x_59;
            let x_61 : obj := ctor_3[Expr.Mul] x_60 x_55;
            ret x_61
          Expr.Val →
            let x_62 : obj := proj[0] x_55;
            let x_63 : obj := Nat.mul x_48 x_62;
            let x_64 : obj := ctor_1[Expr.Val] x_63;
            let x_65 : obj := ctor_3[Expr.Mul] x_64 x_54;
            ret x_65
          Expr.Add →
            let x_66 : obj := Nat.mul x_48 x_58;
            let x_67 : obj := ctor_1[Expr.Val] x_66;
            let x_68 : obj := ctor_3[Expr.Mul] x_67 x_55;
            ret x_68
          Expr.Mul →
            let x_69 : obj := Nat.mul x_48 x_58;
            let x_70 : obj := ctor_1[Expr.Val] x_69;
            let x_71 : obj := ctor_3[Expr.Mul] x_70 x_55;
            ret x_71
        Expr.Add →
          let x_72 : obj := ctor_0[PUnit.unit];
          jmp block_56 x_72
        Expr.Mul →
          let x_73 : obj := ctor_0[PUnit.unit];
          jmp block_56 x_73
    Expr.Add →
      let x_82 : obj := ctor_3[Expr.Mul] x_45 x_46;
      ret x_82
    Expr.Mul →
      let x_83 : obj := ctor_3[Expr.Mul] x_45 x_46;
      ret x_83
[init]
def Expr.size (x_1 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_2 : obj := 1;
    ret x_2
  Expr.Val →
    let x_3 : obj := 1;
    ret x_3
  Expr.Add →
    let x_4 : obj := proj[0] x_1;
    let x_5 : obj := proj[1] x_1;
    let x_6 : obj := Expr.size x_4;
    let x_7 : obj := Expr.size x_5;
    let x_8 : obj := Nat.add x_6 x_7;
    let x_9 : obj := 1;
    let x_10 : obj := Nat.add x_8 x_9;
    ret x_10
  Expr.Mul →
    let x_11 : obj := proj[0] x_1;
    let x_12 : obj := proj[1] x_1;
    let x_13 : obj := Expr.size x_11;
    let x_14 : obj := Expr.size x_12;
    let x_15 : obj := Nat.add x_13 x_14;
    let x_16 : obj := 1;
    let x_17 : obj := Nat.add x_15 x_16;
    ret x_17
[init]
def Expr.toStringAux.match_1._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_7 : obj := proj[0] x_1;
    let x_8 : obj := app x_3 x_7 x_2;
    ret x_8
  Expr.Val →
    let x_9 : obj := proj[0] x_1;
    let x_10 : obj := app x_4 x_9 x_2;
    ret x_10
  Expr.Add →
    let x_11 : obj := proj[0] x_1;
    let x_12 : obj := proj[1] x_1;
    let x_13 : obj := app x_5 x_11 x_12 x_2;
    ret x_13
  Expr.Mul →
    let x_14 : obj := proj[0] x_1;
    let x_15 : obj := proj[1] x_1;
    let x_16 : obj := app x_6 x_14 x_15 x_2;
    ret x_16
def Expr.toStringAux.match_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap Expr.toStringAux.match_1._rarg;
  ret x_2
[init]
def Expr.toStringAux (x_1 : obj) (x_2 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_3 : obj := proj[0] x_1;
    let x_4 : obj := Array.instToStringArray._rarg._closed_1;
    let x_5 : obj := String.append x_2 x_4;
    let x_6 : obj := Nat.repr x_3;
    let x_7 : obj := String.append x_5 x_6;
    ret x_7
  Expr.Val →
    let x_8 : obj := proj[0] x_1;
    let x_9 : obj := Nat.repr x_8;
    let x_10 : obj := String.append x_2 x_9;
    ret x_10
  Expr.Add →
    let x_11 : obj := proj[0] x_1;
    let x_12 : obj := proj[1] x_1;
    let x_13 : obj := prec(_)._closed_3;
    let x_14 : obj := String.append x_2 x_13;
    let x_15 : obj := Expr.toStringAux x_11 x_14;
    let x_16 : obj := Lean.Parser.Syntax.addPrec._closed_11;
    let x_17 : obj := String.append x_15 x_16;
    let x_18 : obj := Expr.toStringAux x_12 x_17;
    let x_19 : obj := prec(_)._closed_7;
    let x_20 : obj := String.append x_18 x_19;
    ret x_20
  Expr.Mul →
    let x_21 : obj := proj[0] x_1;
    let x_22 : obj := proj[1] x_1;
    let x_23 : obj := prec(_)._closed_3;
    let x_24 : obj := String.append x_2 x_23;
    let x_25 : obj := Expr.toStringAux x_21 x_24;
    let x_26 : obj := term_*_._closed_3;
    let x_27 : obj := String.append x_25 x_26;
    let x_28 : obj := Expr.toStringAux x_22 x_27;
    let x_29 : obj := prec(_)._closed_7;
    let x_30 : obj := String.append x_28 x_29;
    ret x_30
[init]
def Expr.eval.match_1._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_6 : obj := proj[0] x_1;
    let x_7 : obj := app x_2 x_6;
    ret x_7
  Expr.Val →
    let x_8 : obj := proj[0] x_1;
    let x_9 : obj := app x_3 x_8;
    ret x_9
  Expr.Add →
    let x_10 : obj := proj[0] x_1;
    let x_11 : obj := proj[1] x_1;
    let x_12 : obj := app x_4 x_10 x_11;
    ret x_12
  Expr.Mul →
    let x_13 : obj := proj[0] x_1;
    let x_14 : obj := proj[1] x_1;
    let x_15 : obj := app x_5 x_13 x_14;
    ret x_15
def Expr.eval.match_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap Expr.eval.match_1._rarg;
  ret x_2
[init]
def Expr.eval (x_1 : obj) : obj :=
  case x_1 : obj of
  Expr.Var →
    let x_2 : obj := 0;
    ret x_2
  Expr.Val →
    let x_3 : obj := proj[0] x_1;
    ret x_3
  Expr.Add →
    let x_4 : obj := proj[0] x_1;
    let x_5 : obj := proj[1] x_1;
    let x_6 : obj := Expr.eval x_4;
    let x_7 : obj := Expr.eval x_5;
    let x_8 : obj := Nat.add x_6 x_7;
    ret x_8
  Expr.Mul →
    let x_9 : obj := proj[0] x_1;
    let x_10 : obj := proj[1] x_1;
    let x_11 : obj := Expr.eval x_9;
    let x_12 : obj := Expr.eval x_10;
    let x_13 : obj := Nat.mul x_11 x_12;
    ret x_13
[init]
def main.match_1._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) : obj :=
  case x_1 : obj of
  List.nil →
    let x_4 : obj := app x_3 x_1;
    ret x_4
  List.cons →
    let x_5 : obj := proj[0] x_1;
    let x_6 : obj := proj[1] x_1;
    case x_6 : obj of
    List.nil →
      let x_7 : obj := app x_2 x_5;
      ret x_7
    List.cons →
      let x_8 : obj := app x_3 x_1;
      ret x_8
def main.match_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap main.match_1._rarg;
  ret x_2
[init]
def main (x_1 : obj) (x_2 : obj) : obj :=
  case x_1 : obj of
  List.nil →
    let x_3 : u32 := 1;
    let x_4 : obj := ctor_0[EStateM.Result.ok] x_3 x_2;
    ret x_4
  List.cons →
    let x_5 : obj := proj[0] x_1;
    let x_6 : obj := proj[1] x_1;
    case x_6 : obj of
    List.nil →
      let x_7 : obj := String.toNat! x_5;
      let x_8 : obj := 1;
      let x_9 : obj := Expr.mkExpr x_7 x_8;
      let x_10 : obj := Expr.eval x_9;
      let x_11 : obj := Expr.reassoc x_9;
      let x_12 : obj := Expr.constFolding x_11;
      let x_13 : obj := Expr.eval x_12;
      let x_14 : obj := Nat.repr x_10;
      let x_15 : obj := _private.Init.Data.Format.Basic.0.Std.Format.be._closed_1;
      let x_16 : obj := String.append x_14 x_15;
      let x_17 : obj := Nat.repr x_13;
      let x_18 : obj := String.append x_16 x_17;
      let x_19 : obj := IO.println._at.Lean.instEval._spec_1 x_18 x_2;
      case x_19 : obj of
      EStateM.Result.ok →
        let x_20 : obj := proj[1] x_19;
        let x_21 : u32 := 0;
        let x_22 : obj := ctor_0[EStateM.Result.ok] x_21 x_20;
        ret x_22
      EStateM.Result.error →
        let x_23 : obj := proj[0] x_19;
        let x_24 : obj := proj[1] x_19;
        let x_25 : obj := ctor_1[EStateM.Result.error] x_23 x_24;
        ret x_25
    List.cons →
      let x_26 : u32 := 1;
      let x_27 : obj := ctor_0[EStateM.Result.ok] x_26 x_2;
      ret x_27
